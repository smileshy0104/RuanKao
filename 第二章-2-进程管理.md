# 第二章 操作系统知识 - 第二部分：进程管理 ⭐⭐⭐

> **重要提示**：进程管理是操作系统考试的**最核心内容**，每年必考，分值占操作系统的60%以上。本节内容需要深入理解并熟练掌握。

---

## 📚 本部分内容导览

```mermaid
graph TB
    A[进程管理 ⭐⭐⭐<br/>核心考点章节] --> B[2.1 进程的基本概念]
    A --> C[2.2 进程三态图 ⭐⭐⭐]
    A --> D[2.3 进程资源图与死锁检测 ⭐⭐⭐]
    A --> E[2.4 进程同步与互斥 PV操作 ⭐⭐⭐]
    A --> F[2.5 生产者-消费者问题 ⭐⭐⭐]
    A --> G[2.6 前驱图 ⭐⭐]
    A --> H[2.7 进程调度算法 ⭐⭐⭐]
    A --> I[2.8 三级调度 ⭐]
    A --> J[2.9 中断机制 ⭐⭐]

    B --> B1[进程组成]
    B --> B2[进程 vs 线程 ⭐⭐]

    C --> C1[三种状态]
    C --> C2[状态转换规则 必考]

    D --> D1[阻塞节点判断]
    D --> D2[死锁检测]

    E --> E1[PV操作原理]
    E --> E2[信号量含义]

    F --> F1[经典案例]
    F --> F2[代码实现]

    J --> J1[中断分类]
    J --> J2[用户态vs内核态]
    J --> J3[单体内核vs微内核]

    style A fill:#f9f,stroke:#333,stroke-width:4px
    style C fill:#fcc,stroke:#333,stroke-width:3px
    style D fill:#fcc,stroke:#333,stroke-width:3px
    style E fill:#fcc,stroke:#333,stroke-width:3px
    style F fill:#fcc,stroke:#333,stroke-width:3px
```

**重点标注**：
- ⭐ 基础了解（偶尔考察）
- ⭐⭐ 重要考点（需要理解掌握）
- ⭐⭐⭐ 核心考点（必考内容，需熟练掌握）

---

## 2.1 进程的基本概念

### 什么是进程？

**简单理解**：进程 = 运行中的程序

```mermaid
graph LR
    A[程序 vs 进程] --> B[程序 Program]
    A --> C[进程 Process ⭐]

    B --> B1[状态：静态的]
    B --> B2[位置：存储在<br/>外存 硬盘 中]
    B --> B3[举例：桌面上的<br/>QQ图标 未运行]

    C --> C1[状态：动态的<br/>运行中的]
    C --> C2[位置：被调度到<br/>内存中执行]
    C --> C3[举例：双击QQ后<br/>正在运行的QQ程序]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style C fill:#fcc,stroke:#333,stroke-width:2px
```

---

### 进程的组成

一个进程由**三部分**组成：

```mermaid
graph TB
    A[进程的组成] --> B[① PCB<br/>进程控制块 ⭐⭐]
    A --> C[② 程序段<br/>Program]
    A --> D[③ 数据段<br/>Data]

    B --> B1[Process Control Block]
    B1 --> B11[作用：唯一标识进程]
    B11 --> B111[内容：进程ID、进程状态<br/>寄存器信息等]

    C --> C1[进程要执行的代码]

    D --> D1[进程运行所需的数据]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style B fill:#fcc,stroke:#333,stroke-width:2px
```

> **考点提示**：PCB（进程控制块）是进程的核心，用于唯一标识和管理进程。

---

### 进程 vs 线程 ⭐⭐（重要对比）

```mermaid
graph TB
    A[进程 vs 线程] --> B[传统进程的两个特性]
    A --> C[引入线程后的变化]

    B --> B1[① 可拥有资源的<br/>独立单位]
    B --> B2[② 可独立调度和<br/>分配的基本单位]

    C --> C1[进程：拥有资源的<br/>基本单位 ⭐]
    C --> C2[线程：独立调度的<br/>基本单位 ⭐]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style C1 fill:#fcf,stroke:#333,stroke-width:2px
    style C2 fill:#fcc,stroke:#333,stroke-width:2px
```

**核心区别**：

```mermaid
graph TB
    A[进程与线程的关系] --> B[区别1：调度单位的变化]
    A --> C[区别2：资源拥有关系]

    B --> B1[传统进程：<br/>既拥有资源<br/>又是调度单位]
    B --> B2[引入线程后：<br/>进程只拥有资源<br/>线程成为调度单位]

    C --> C1[进程：拥有资源]
    C --> C2[线程：不拥有资源<br/>共享进程资源]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style B2 fill:#fcc,stroke:#333,stroke-width:2px
    style C2 fill:#fcf,stroke:#333,stroke-width:2px
```

---

### 线程的资源特点 ⭐⭐

```mermaid
graph LR
    A[线程的资源] --> B[不拥有的资源<br/>与进程共享 ⭐]
    A --> C[拥有的资源<br/>线程独有]

    B --> B1[公共数据]
    B --> B2[全局变量]
    B --> B3[代码段]
    B --> B4[文件数据]

    C --> C1[线程ID 标识]
    C --> C2[程序计数器 PC]
    C --> C3[寄存器组]
    C --> C4[栈 Stack]
    C --> C5[线程控制块 TCB]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style B fill:#fcf,stroke:#333,stroke-width:2px
    style C fill:#cfc,stroke:#333,stroke-width:2px
```

**关键理解**：

1. **线程不拥有资源**：
   - 线程本身不拥有系统资源
   - 与同一进程的其他线程**共享**进程的全部资源

2. **线程拥有的最小资源**：
   - 线程标识（Thread ID）
   - 程序计数器（PC）：记录线程执行到哪里
   - 寄存器组：保存线程的工作变量
   - 栈（Stack）：保存线程的执行历史
   - 线程控制块（TCB）：类似进程的PCB

> **形象比喻**：
> - 进程 = 一个公司（拥有办公室、设备等资源）
> - 线程 = 公司里的员工（共享公司资源，但每个人有自己的工位和工作记录）

---

### 进程与线程对比表

| 特性 | 进程 Process | 线程 Thread |
|------|-------------|-------------|
| **定义** | 资源分配的基本单位 | CPU调度的基本单位 |
| **资源拥有** | 拥有独立的资源空间 | 不拥有资源，共享进程资源 |
| **独立性** | 进程间相互独立 | 线程间共享进程资源 |
| **开销** | 创建和切换开销大 | 创建和切换开销小 ⭐ |
| **通信** | 进程间通信较复杂（IPC） | 线程间通信简单（共享内存） |
| **崩溃影响** | 一个进程崩溃不影响其他进程 | 一个线程崩溃可能导致整个进程崩溃 |

> **考试重点**：
> - 线程是调度的基本单位
> - 进程是资源拥有的基本单位
> - 线程共享进程资源，开销小

---

## 2.2 进程的三态图 ⭐⭐⭐（必考知识点）

### 进程的三种基本状态

```mermaid
graph TB
    A[进程的三种状态] --> B[① 运行态 Running]
    A --> C[② 就绪态 Ready]
    A --> D[③ 阻塞态 Blocked / Waiting]

    B --> B1[什么都不缺<br/>有CPU，正在执行]

    C --> C1[只缺CPU<br/>万事俱备，只欠东风]

    D --> D1[不光缺CPU<br/>还缺其他资源<br/>如IO事件]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style B fill:#cfc,stroke:#333,stroke-width:2px
    style C fill:#fcf,stroke:#333,stroke-width:2px
    style D fill:#fcc,stroke:#333,stroke-width:2px
```

---

### 进程三态转换图 ⭐⭐⭐（核心图形）

```mermaid
stateDiagram-v2
    [*] --> 就绪态: 进程创建

    就绪态 --> 运行态: ② 被调度<br/>获得CPU
    运行态 --> 就绪态: ① 时间片到<br/>释放CPU

    运行态 --> 阻塞态: ③ 等待IO事件<br/>如用户输入、文件读取
    阻塞态 --> 就绪态: ④ 等待的事件发生<br/>重新排队

    运行态 --> [*]: 进程结束

    note right of 就绪态
        只缺CPU
        排队等待调度
    end note

    note right of 运行态
        什么都不缺
        正在执行
    end note

    note right of 阻塞态
        缺CPU和其他资源
        等待IO事件
    end note
```

---

### 状态转换详解

```mermaid
graph TB
    A[进程三态转换详解] --> B[转换① 运行态→就绪态]
    A --> C[转换② 就绪态→运行态]
    A --> D[转换③ 运行态→阻塞态]
    A --> E[转换④ 阻塞态→就绪态]

    B --> B1[触发条件：时间片用完]
    B1 --> B11[原因：分时调度<br/>每个进程只能运行<br/>一个时间片 如100微秒]
    B11 --> B111[结果：释放CPU<br/>进入就绪队列排队]

    C --> C1[触发条件：被调度器选中]
    C1 --> C11[原因：轮到该进程运行]
    C11 --> C111[结果：获得CPU<br/>开始执行]

    D --> D1[触发条件：等待某个<br/>外部事件 最常见：等待IO]
    D1 --> D11[举例：程序需要用户输入数据<br/>程序需要读取文件<br/>程序需要网络响应]
    D11 --> D111[结果：CPU不会傻等<br/>将进程置为阻塞态<br/>去运行其他进程]

    E --> E1[触发条件：等待的<br/>事件发生了]
    E1 --> E11[举例：用户输入完成<br/>文件读取完成<br/>网络响应到达]
    E11 --> E111[结果：进入就绪队列<br/>等待再次被调度]

    style A fill:#f9f,stroke:#333,stroke-width:3px
```

---

### 重要规则（考试常考）⭐⭐⭐

```mermaid
graph TB
    A[进程三态转换规则] --> B[规则1：阻塞态不能<br/>直接到运行态 ⭐⭐⭐]
    A --> C[规则2：就绪态不能<br/>直接到阻塞态 ⭐⭐⭐]

    B --> B1[❌ 错误：<br/>阻塞态 ──直接──> 运行态]
    B --> B2[✅ 正确：<br/>阻塞态 → 就绪态 → 运行态]
    B2 --> B21[原因：想要获得CPU<br/>必须先进入就绪队列排队]

    C --> C1[❌ 错误：<br/>就绪态 ──直接──> 阻塞态]
    C --> C2[✅ 正确：<br/>只有运行态才能进入阻塞态]
    C2 --> C21[原因：就绪态和阻塞态<br/>本质上都是没有CPU]
    C2 --> C22[原因：只有在运行时<br/>才会遇到需要等待的IO事件]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style B fill:#fcc,stroke:#333,stroke-width:2px
    style C fill:#fcc,stroke:#333,stroke-width:2px
```

---

### 三态图记忆技巧

| 状态 | 记忆口诀 | 是否有CPU | 是否缺其他资源 |
|------|---------|----------|---------------|
| 运行态 | 什么都不缺 | ✅ 有 | ✅ 没缺 |
| 就绪态 | 只缺CPU | ❌ 没有 | ✅ 没缺 |
| 阻塞态 | 啥都缺 | ❌ 没有 | ❌ 缺IO等资源 |

> **考试技巧**：遇到进程状态转换题，先画出三态图，再根据条件判断转换是否合法。

---

## 2.3 进程资源图 ⭐⭐⭐（死锁检测的核心工具）

### 什么是进程资源图？

**定义**：进程资源图用于表示系统中**进程**和**资源**之间的分配和请求关系。

**作用**：
1. 直观展示进程和资源的关系
2. 判断系统是否处于死锁状态
3. 判断系统是否可以化简（避免死锁）

---

### 进程资源图的基本元素

```mermaid
graph TB
    A[进程资源图的组成元素] --> B[① 资源 Resource]
    A --> C[② 进程 Process]
    A --> D[③ 箭头 Arrow]

    B --> B1[图形表示：长方形 □]
    B --> B2[标识：R1, R2, R3 ...]
    B --> B3[资源个数：长方形内<br/>的圆圈数量]

    C --> C1[图形表示：圆形 ○]
    C --> C2[标识：P1, P2, P3 ...]

    D --> D1[资源 → 进程：<br/>资源已分配给进程]
    D --> D2[进程 → 资源：<br/>进程请求资源]

    style A fill:#f9f,stroke:#333,stroke-width:3px
```

---

### 进程资源图示例

```mermaid
graph LR
    R1[R1资源<br/>总数:2个]
    R2[R2资源<br/>总数:3个]

    P1((P1进程))
    P2((P2进程))
    P3((P3进程))

    R1 -->|已分配1个| P1
    R1 -->|已分配1个| P2

    R2 -->|已分配2个| P2

    P2 -->|请求1个| R1
    P3 -->|请求1个| R2

    style R1 fill:#cfc,stroke:#333,stroke-width:2px
    style R2 fill:#cfc,stroke:#333,stroke-width:2px
    style P1 fill:#fcf,stroke:#333,stroke-width:2px
    style P2 fill:#fcc,stroke:#333,stroke-width:2px
    style P3 fill:#fcf,stroke:#333,stroke-width:2px
```

**分析**：
- R1：总数2个，已分配2个（P1:1, P2:1），剩余0个
- R2：总数3个，已分配2个（P2:2），剩余1个
- P2请求R1：但R1已没有剩余 → P2是**阻塞节点**
- P3请求R2：R2还有1个剩余 → P3是**非阻塞节点**

---

### 如何分析进程资源图？ ⭐⭐⭐（考试重点）

```mermaid
graph TB
    A[分析进程资源图的三步法] --> B[第一步：计算每个资源<br/>的剩余数量]
    A --> C[第二步：判断每个进程<br/>是否为阻塞节点]
    A --> D[第三步：尝试化简<br/>进程资源图]

    B --> B1[剩余 = 总数 - 已分配数量]
    B1 --> B11[看出去的箭头数量]

    C --> C1[阻塞节点：请求一个<br/>不可能得到的资源]
    C --> C2[非阻塞节点：请求的<br/>资源有机会得到]
    C2 --> C21[看进来的箭头与<br/>剩余资源的关系]

    D --> D1[从非阻塞节点开始运行]
    D --> D2[运行完释放资源]
    D --> D3[看能否让所有<br/>进程运行完]

    style A fill:#f9f,stroke:#333,stroke-width:3px
```

---

### 阻塞节点 vs 非阻塞节点 ⭐⭐⭐

```mermaid
graph TB
    A[如何判断阻塞节点？] --> B[阻塞节点]
    A --> C[非阻塞节点]

    B --> B1[进程请求的资源<br/>当前系统中没有剩余]
    B1 --> B11[不可能得到 → 阻塞]

    C --> C1[进程请求的资源<br/>当前系统中有剩余]
    C1 --> C11[有机会得到 → 非阻塞]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style B fill:#fcc,stroke:#333,stroke-width:2px
    style C fill:#cfc,stroke:#333,stroke-width:2px
```

**易错点** ⚠️：

假设R2有1个剩余资源，P1和P3都请求R2，它们是阻塞节点吗？

```
情况：
- R2剩余：1个
- P1请求：1个
- P3请求：1个

❌ 错误理解：两个进程抢一个资源，都是阻塞节点
✅ 正确理解：两个进程都是非阻塞节点

原因：
- 虽然不能同时满足
- 但每个进程都有机会得到这个资源
- 调度器可以选择先满足P1或P3
- 所以都是非阻塞节点
```

---

### 死锁检测 ⭐⭐⭐

```mermaid
graph TB
    A[死锁状态] --> B[所有进程都是<br/>阻塞节点]
    B --> C[每个进程都在等待<br/>一个永远不会<br/>释放的资源]

    D[典型死锁场景] --> E[资源R1：1个<br/>资源R2：1个]

    E --> F[P1持有R1<br/>请求R2]
    E --> G[P2持有R2<br/>请求R1]

    F --> H[P1等待P2释放R2]
    G --> I[P2等待P1释放R1]

    H --> J[互相等待 → 死锁 ⚠️]
    I --> J

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style B fill:#fcc,stroke:#333,stroke-width:2px
    style J fill:#fcc,stroke:#333,stroke-width:3px
```

---

## 2.4 进程的同步与互斥 ⭐⭐⭐（PV操作）

### 基本概念

```mermaid
graph TB
    A[互斥与同步] --> B[互斥<br/>Mutual Exclusion]
    A --> C[同步<br/>Synchronization]

    B --> B1[同一时间，只能有<br/>一个进程使用某个资源]
    B1 --> B11[资源：临界资源]
    B1 --> B12[操作代码：临界区]
    B1 --> B13[实现方式：加锁/解锁]

    C --> C1[多个进程可以<br/>并发执行<br/>但有速度差异]
    C1 --> C11[资源可以共享<br/>但速度不同]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style B fill:#fcf,stroke:#333,stroke-width:2px
    style C fill:#cfc,stroke:#333,stroke-width:2px
```

**临界资源** ⭐：
- 同一时间只能由一个进程访问的资源
- 例如：打印机、共享内存、数据库记录

**临界区** ⭐：
- 对临界资源进行操作的那段程序代码
- 注意：临界区是**程序代码**，临界资源是**资源**

---

### 信号量（Semaphore）⭐⭐⭐

```mermaid
graph TB
    A[信号量分类] --> B[互斥信号量]
    A --> C[同步信号量]

    B --> B1[初值：1]
    B --> B2[作用：保证同一时间<br/>只有一个进程<br/>访问资源]

    C --> C1[初值：共享资源的数量]
    C --> C2[作用：管理可共享<br/>资源的分配]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style B fill:#fcf,stroke:#333,stroke-width:2px
    style C fill:#cfc,stroke:#333,stroke-width:2px
```

---

**信号量的含义**：

```mermaid
graph TB
    A[信号量S的取值含义] --> B[S >= 0]
    A --> C[S < 0]

    B --> B1[表示可用资源的数量]

    C --> C1[表示正在阻塞等待<br/>的进程数量]
    C1 --> C11[abs S = 阻塞进程数]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style B fill:#cfc,stroke:#333,stroke-width:2px
    style C fill:#fcc,stroke:#333,stroke-width:2px
```

**示例理解**：

假设公司有3台电脑，5个程序员需要使用：

```
场景分析：
- 初始：S = 3（3台电脑）
- 程序员A申请：S = 2
- 程序员B申请：S = 1
- 程序员C申请：S = 0（3台电脑用完）
- 程序员D申请：S = -1（表示1人在排队）
- 程序员E申请：S = -2（表示2人在排队）
```

> **关键理解**：S < 0时，abs(S)表示有多少人在阻塞队列中排队等待。

---

### PV操作 ⭐⭐⭐（核心考点）

```mermaid
flowchart TD
    A[P操作 申请资源] --> B[第一步：S = S - 1]
    B --> C{判断S的值}
    C -->|S < 0| D[进程阻塞<br/>进入等待队列]
    C -->|S >= 0| E[继续执行]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style D fill:#fcc,stroke:#333,stroke-width:2px
    style E fill:#cfc,stroke:#333,stroke-width:2px
```

```mermaid
flowchart TD
    A[V操作 释放资源] --> B[第一步：S = S + 1]
    B --> C{判断S的值}
    C -->|S <= 0| D[唤醒等待队列中<br/>的一个进程]
    C -->|S > 0| E[无需唤醒]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style D fill:#fcf,stroke:#333,stroke-width:2px
    style E fill:#cfc,stroke:#333,stroke-width:2px
```

---

### 为什么V操作要判断S <= 0？ ⭐⭐

```mermaid
graph TB
    A[V操作判断S <= 0的原因] --> B[场景说明]

    B --> C[当前状态：S = -2<br/>表示有2个进程在排队]

    C --> D[执行V操作：<br/>S = -2 + 1 = -1]

    D --> E[S = -1，仍然 <= 0]

    E --> F[说明：还有1个进程<br/>在排队]

    F --> G[应该：唤醒队列中<br/>的一个进程]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style E fill:#fcc,stroke:#333,stroke-width:2px
    style G fill:#cfc,stroke:#333,stroke-width:2px
```

**总结**：
- S <= 0 表示有进程在排队
- 释放资源后，应该优先给排队的进程
- 如果S > 0，说明没有进程排队，资源直接放回资源池

---

## 2.5 生产者-消费者问题 ⭐⭐⭐（经典同步互斥问题）

### 问题描述

```mermaid
graph LR
    A[生产者进程] -->|生产商品| B[仓库 缓冲区]
    B -->|取出商品| C[消费者进程]

    A --> A1[生产商品]
    A1 --> A2[将商品放入仓库]

    B --> B1[容量有限]
    B --> B2[只能被独占使用<br/>互斥访问]

    C --> C1[从仓库取出商品]
    C1 --> C2[消费商品]

    style B fill:#fcf,stroke:#333,stroke-width:3px
```

---

### 约束条件

1. **互斥约束**：仓库同一时间只能被一个进程使用（生产者或消费者）
2. **同步约束**：
   - 生产者：需要有空位才能放商品
   - 消费者：需要有商品才能取商品

---

### 信号量设置

```mermaid
graph TB
    A[信号量定义] --> B[S0：互斥信号量]
    A --> C[S1：同步信号量 空位数]
    A --> D[S2：同步信号量 商品数]

    B --> B1[初值：1]
    B --> B2[作用：保证仓库的<br/>互斥访问]

    C --> C1[初值：仓库容量 如10]
    C --> C2[作用：记录仓库的<br/>空闲位置数]

    D --> D1[初值：0]
    D --> D2[作用：记录仓库中的<br/>商品数量]

    style A fill:#f9f,stroke:#333,stroke-width:3px
```

---

### 生产者和消费者流程图

```mermaid
sequenceDiagram
    participant 生产者
    participant S0互斥信号量
    participant S1空位数
    participant S2商品数
    participant 仓库
    participant 消费者

    Note over 生产者: 生产一个商品

    生产者->>S0互斥信号量: P(S0) 申请仓库使用权
    生产者->>S1空位数: P(S1) 申请一个空位
    生产者->>仓库: 将商品放入仓库
    生产者->>S2商品数: V(S2) 商品数+1
    生产者->>S0互斥信号量: V(S0) 释放仓库

    Note over 消费者: 准备消费

    消费者->>S0互斥信号量: P(S0) 申请仓库使用权
    消费者->>S2商品数: P(S2) 申请一个商品
    消费者->>仓库: 从仓库取出商品
    消费者->>S1空位数: V(S1) 空位数+1
    消费者->>S0互斥信号量: V(S0) 释放仓库

    Note over 消费者: 消费商品
```

---

### 生产者进程代码

```
生产者进程：

    生产一个商品

    P(S0)  ← 申请仓库的独占使用权

    P(S1)  ← 申请一个空位

    将商品放入仓库

    V(S2)  ← 商品数量+1

    V(S0)  ← 释放仓库的使用权
```

---

### 消费者进程代码

```
消费者进程：

    P(S0)  ← 申请仓库的独占使用权

    P(S2)  ← 申请一个商品

    从仓库取出商品

    V(S1)  ← 空位数+1

    V(S0)  ← 释放仓库的使用权

    消费商品
```

---

### 代码对比分析

| 操作 | 生产者 | 消费者 | 说明 |
|------|--------|--------|------|
| **第1步** | 生产商品 | P(S0) | 生产者先生产，消费者先申请仓库 |
| **第2步** | P(S0) | P(S2) | 都申请互斥资源或同步资源 |
| **第3步** | P(S1) | 取出商品 | 生产者申请空位，消费者直接取 |
| **第4步** | 放入商品 | V(S1) | 生产者放入，消费者释放空位 |
| **第5步** | V(S2) | V(S0) | 生产者释放商品数，消费者释放仓库 |
| **第6步** | V(S0) | 消费商品 | 生产者释放仓库，消费者消费 |

---

## 2.6 前驱图 ⭐⭐（进程执行顺序）

### 什么是前驱图？

**定义**：前驱图用于表示进程之间的**执行先后关系**。

```mermaid
graph TB
    A[前驱图的基本元素] --> B[节点：表示进程]
    A --> C[有向边：表示执行顺序]

    B --> B1[A、B、C、D、E...]

    C --> C1[A → B 表示<br/>A执行完后，B才能执行]

    style A fill:#f9f,stroke:#333,stroke-width:3px
```

---

### 前驱图示例

**示例1：简单前驱图**

```mermaid
graph TD
    A[进程A] --> B[进程B]
    B --> C[进程C]

    style A fill:#cfc,stroke:#333,stroke-width:2px
    style B fill:#fcf,stroke:#333,stroke-width:2px
    style C fill:#fcc,stroke:#333,stroke-width:2px
```

说明：
- A执行完 → B才能执行
- B执行完 → C才能执行

---

**示例2：复杂前驱图**

```mermaid
graph TD
    A[进程A] --> D[进程D]
    B[进程B] --> D
    C[进程C] --> D
    D --> E[进程E]

    style A fill:#cfc,stroke:#333,stroke-width:2px
    style B fill:#cfc,stroke:#333,stroke-width:2px
    style C fill:#cfc,stroke:#333,stroke-width:2px
    style D fill:#fcf,stroke:#333,stroke-width:2px
    style E fill:#fcc,stroke:#333,stroke-width:2px
```

说明：
- A、B、C可以并发执行
- A、B、C都执行完后，D才能执行
- D执行完后，E才能执行

---

### 前驱图与PV操作的关系 ⭐⭐⭐

**核心原理**：前驱图中的每一条边对应一个**信号量**

```mermaid
graph TB
    A[前驱图转换为PV操作] --> B[每条边 = 一个信号量]
    A --> C[箭头出去 前驱 → V操作<br/>释放信号量]
    A --> D[箭头进来 后继 → P操作<br/>申请信号量]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style C fill:#cfc,stroke:#333,stroke-width:2px
    style D fill:#fcf,stroke:#333,stroke-width:2px
```

---

**示例：前驱图转PV操作**

```mermaid
graph LR
    A[进程A] -->|信号量S1| B[进程B]
    B -->|信号量S2| C[进程C]

    A1[进程A代码] --> A2[执行A的代码]
    A2 --> A3[V S1<br/>通知B可以执行了]

    B1[进程B代码] --> B2[P S1<br/>等待A执行完]
    B2 --> B3[执行B的代码]
    B3 --> B4[V S2<br/>通知C可以执行了]

    C1[进程C代码] --> C2[P S2<br/>等待B执行完]
    C2 --> C3[执行C的代码]

    style A fill:#cfc,stroke:#333,stroke-width:2px
    style B fill:#fcf,stroke:#333,stroke-width:2px
    style C fill:#fcc,stroke:#333,stroke-width:2px
```

---

**多前驱情况**：

```mermaid
graph TB
    A[进程A] -->|S1| D[进程D]
    B[进程B] -->|S2| D
    C[进程C] -->|S3| D
    D -->|S4| E[进程E]

    subgraph 进程D的代码
    D1[P S1 等待A]
    D2[P S2 等待B]
    D3[P S3 等待C]
    D4[执行D]
    D5[V S4]
    D1 --> D2 --> D3 --> D4 --> D5
    end

    style D fill:#fcf,stroke:#333,stroke-width:3px
```

**关键理解**：
- D有3个前驱（A、B、C）
- 所以D要执行3次P操作
- 只有A、B、C都执行完，D才能开始

---

## 2.7 进程调度算法 ⭐⭐⭐

### 调度算法概述

```mermaid
graph TB
    A[进程调度算法分类] --> B[① 时间片轮转<br/>分时调度 ⭐⭐]
    A --> C[② 先来先服务 FCFS]
    A --> D[③ 优先级调度]
    A --> E[④ 多级反馈调度 ⭐⭐]

    B --> B1[现代操作系统<br/>普遍采用]

    C --> C1[First Come<br/>First Served]

    D --> D1[根据进程优先级调度]

    E --> E1[时间片轮转 +<br/>优先级的综合]

    style A fill:#f9f,stroke:#333,stroke-width:3px
```

---

### 1. 时间片轮转调度 ⭐⭐（分时调度）

```mermaid
graph TB
    A[时间片轮转] --> B[每个进程分配<br/>固定时间片<br/>如100微秒]

    B --> C[进程轮流执行]
    C --> C1[进程A执行100微秒]
    C --> C2[进程B执行100微秒]
    C --> C3[进程C执行100微秒]
    C --> C4[... 循环]

    D[特点] --> D1[公平：每个进程<br/>时间相同]
    D --> D2[响应时间短：不会<br/>长时间等待]

    E[缺点] --> E1[频繁切换进程<br/>有开销]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style D1 fill:#cfc,stroke:#333,stroke-width:2px
    style D2 fill:#cfc,stroke:#333,stroke-width:2px
```

---

### 2. 先来先服务（FCFS）

```mermaid
graph LR
    A[先来先服务 FCFS] --> B[按进程到达的<br/>先后顺序执行]

    B --> C[先到先执行]
    B --> D[后到后执行]

    E[优点] --> E1[简单易实现]
    E --> E2[公平 先来先得]

    F[缺点] --> F1[可能导致长作业<br/>阻塞短作业<br/>护航效应]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style F1 fill:#fcc,stroke:#333,stroke-width:2px
```

**示例**：
```
进程到达顺序：P1（需要10秒）→ P2（需要1秒）→ P3（需要1秒）

执行顺序：
P1执行10秒 → P2执行1秒 → P3执行1秒

问题：
P2和P3等待了10秒才开始执行（虽然它们只需1秒）
```

---

### 3. 优先级调度

```mermaid
graph TB
    A[优先级调度] --> B[根据进程优先级<br/>高低决定执行顺序]

    B --> C[高优先级先执行]
    B --> D[低优先级后执行]

    E[分类] --> F[可剥夺 Preemptive ⭐]
    E --> G[不可剥夺<br/>Non-Preemptive]

    F --> F1[高优先级进程<br/>可以抢占CPU]
    F1 --> F11[正在运行的<br/>低优先级进程被暂停]

    G --> G1[高优先级进程<br/>必须等待]
    G1 --> G11[当前进程运行完<br/>才能执行]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style F fill:#fcc,stroke:#333,stroke-width:2px
```

---

### 4. 多级反馈调度 ⭐⭐

**原理**：时间片轮转 + 优先级的综合

```mermaid
graph TB
    A[多级反馈调度] --> B[设置多个优先级队列]

    B --> C[队列1：最高优先级]
    B --> D[队列2：次高优先级]
    B --> E[队列3：低优先级]

    C --> C1[时间片：100微秒]
    D --> D1[时间片：200微秒]
    E --> E1[时间片：400微秒]

    F[每个队列内部] --> F1[时间片轮转]

    G[队列之间] --> G1[优先级调度]
    G1 --> G11[只有高优先级队列为空<br/>才执行低优先级队列]

    style A fill:#f9f,stroke:#333,stroke-width:3px
```

---

**执行规则**：

```mermaid
graph TD
    A[多级反馈调度执行流程] --> B[1. 新进程进入<br/>最高优先级队列 队列1]

    B --> C[2. 在队列1中<br/>时间片轮转执行]

    C --> D{时间片用完<br/>还没执行完?}

    D -->|是| E[3. 降级到<br/>下一个队列 队列2]
    D -->|否| F[进程完成]

    E --> G[4. 在队列2中<br/>继续执行]

    G --> H{还没执行完?}

    H -->|是| I[5. 继续降级到<br/>队列3...]
    H -->|否| F

    style A fill:#f9f,stroke:#333,stroke-width:3px
```

**优点**：
- 短作业优先（在高优先级队列快速完成）
- 长作业也不会饿死（最终会执行）
- 兼顾公平性和效率

---

## 2.8 高级调度、中级调度、低级调度 ⭐

```mermaid
graph TB
    A[操作系统的三级调度] --> B[高级调度 作业调度 ⭐]
    A --> C[中级调度 交换调度]
    A --> D[低级调度 进程调度 ⭐⭐⭐]

    B --> B1[外存 → 内存]
    B --> B2[几乎不考]

    C --> C1[交换区 → 内存]
    C --> C2[了解即可]

    D --> D1[内存 → CPU]
    D --> D2[考试重点<br/>就是上面讲的<br/>进程调度算法]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style D fill:#fcc,stroke:#333,stroke-width:3px
```

**低级调度**（进程调度）：
- 决定内存中哪个进程可以占用CPU
- 这是我们主要学习的内容
- 调度算法：FCFS、优先级、时间片轮转、多级反馈

---

## 2.9 中断机制 ⭐⭐（重要概念）

### 什么是中断？

**定义**：某些事件的发生，导致当前正在运行的进程被暂停，转而去处理这些事件。

```mermaid
graph TB
    A[中断机制] --> B[本质：事件驱动架构]

    C[中断的作用] --> D[暂停当前进程]
    C --> E[处理紧急事件]
    C --> F[提高系统响应速度]

    G[典型场景] --> H[高优先级进程到来<br/>可剥夺调度]
    G --> I[IO设备完成操作]
    G --> J[发生错误或异常]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style C fill:#fcf,stroke:#333,stroke-width:2px
```

> **形象理解**：中断就像你正在工作时突然有人敲门，你需要暂停工作去开门，处理完后再回来继续工作。

---

### 中断的基本概念 ⭐⭐

```mermaid
graph LR
    A[中断的三个核心概念] --> B[中断源<br/>Interrupt Source]
    A --> C[中断处理程序<br/>ISR]
    A --> D[中断响应<br/>Response]

    B --> B1[引起中断的事件]
    B1 --> B11[硬件事件<br/>软件事件]

    C --> C1[处理中断事件<br/>的程序]

    D --> D1[暂停当前进程]
    D --> D2[保存现场]
    D --> D3[转向中断处理程序]

    style A fill:#f9f,stroke:#333,stroke-width:3px
```

---

### 中断处理流程 ⭐

```mermaid
flowchart TD
    A[中断发生] --> B{是否允许<br/>中断嵌套?}

    B -->|不允许| C[关中断<br/>禁止新中断]
    B -->|允许| D[保持中断开启]

    C --> E[中断响应]
    D --> E

    E --> F[保存现场<br/>堆、栈、寄存器]
    F --> G[找到中断处理程序<br/>入口地址]
    G --> H[执行中断处理程序]
    H --> I[恢复现场]
    I --> J[中断返回<br/>继续执行原进程]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style F fill:#fcf,stroke:#333,stroke-width:2px
    style I fill:#cfc,stroke:#333,stroke-width:2px
```

**关键步骤**：
1. **关中断**（如果不允许嵌套）：防止中断处理过程中被新中断打断
2. **保存现场**：保存当前进程的堆、栈、寄存器等状态
3. **执行中断处理**：运行中断处理程序（ISR）
4. **恢复现场**：恢复被中断进程的状态
5. **中断返回**：继续执行原进程

---

### 中断的五种分类 ⭐⭐⭐（考试重点）

```mermaid
graph TB
    A[中断的五种类型] --> B[① 程序性中断<br/>Program]
    A --> C[② 外中断<br/>External]
    A --> D[③ 输入输出中断<br/>I/O]
    A --> E[④ 硬件故障中断<br/>Hardware Fault]
    A --> F[⑤ 访管中断<br/>Supervisor Call]

    B --> B1[程序错误导致]
    B1 --> B11[内存越界<br/>除零错误<br/>段错误 Core Dump]

    C --> C1[外部事件触发]
    C1 --> C11[时钟中断<br/>操作员强制终止<br/>Ctrl+C]

    D --> D1[外设操作相关]
    D1 --> D11[打印机缺纸<br/>磁盘读取完成<br/>网络数据到达]

    E --> E1[硬件故障]
    E1 --> E11[电源故障<br/>内存故障<br/>硬件损坏]

    F --> F1[系统调用]
    F1 --> F11[用户态→内核态<br/>打开文件<br/>网络通信]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style B fill:#fcf,stroke:#333,stroke-width:2px
    style C fill:#cfc,stroke:#333,stroke-width:2px
    style D fill:#fec,stroke:#333,stroke-width:2px
    style E fill:#fcc,stroke:#333,stroke-width:2px
    style F fill:#ccf,stroke:#333,stroke-width:2px
```

---

### 中断类型详解

#### 1. 程序性中断 ⭐⭐

**特点**：由程序自身的错误或特定状态引起

```mermaid
graph TB
    A[程序性中断] --> B[常见类型]

    B --> C[内存越界<br/>访问非法地址]
    B --> D[除零错误<br/>0作除数]
    B --> E[段错误 Segmentation Fault<br/>Core Dump]
    B --> F[非法指令]
    B --> G[栈溢出]

    H[处理方式] --> I[终止程序]
    H --> J[抛出异常]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style E fill:#fcc,stroke:#333,stroke-width:2px
```

> **开发经验**：程序员最怕的就是Core Dump（核心转储），因为这意味着程序崩溃了。

---

#### 2. 外中断 ⭐

**特点**：由外部事件触发，与当前进程无关

```mermaid
graph LR
    A[外中断] --> B[时钟中断<br/>Timer]
    A --> C[操作员控制台中断<br/>Ctrl+C]
    A --> D[外部信号]

    E[特点] --> F[外部触发]
    E --> G[强制终止]
    E --> H[主动中断]

    style A fill:#f9f,stroke:#333,stroke-width:3px
```

**举例**：
- 用户按下Ctrl+C强制终止程序
- 系统管理员kill掉进程
- 定时器到期

---

#### 3. 输入输出中断 ⭐⭐

**特点**：外设操作完成或发生异常

```mermaid
graph TB
    A[I/O中断] --> B[正常完成]
    A --> C[异常情况]

    B --> B1[磁盘读取完成]
    B --> B2[网络数据到达]
    B --> B3[打印任务完成]

    C --> C1[打印机缺纸<br/>缺墨]
    C --> C2[磁盘无数据]
    C --> C3[网络超时]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style B fill:#cfc,stroke:#333,stroke-width:2px
    style C fill:#fcc,stroke:#333,stroke-width:2px
```

> **关键理解**：I/O中断不一定是故障，也可能是正常操作完成的通知。

---

#### 4. 硬件故障中断 ⭐

**特点**：硬件出现故障

```mermaid
graph LR
    A[硬件故障中断] --> B[电源故障<br/>停电]
    A --> C[内存故障<br/>坏块]
    A --> D[硬件损坏]

    E[vs I/O中断] --> F[I/O中断：<br/>缺纸、缺墨<br/>不是故障]
    E --> G[硬件故障：<br/>真正的<br/>硬件损坏]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style G fill:#fcc,stroke:#333,stroke-width:2px
```

**区分要点**：
- 打印机缺纸 → I/O中断（可以补充）
- 打印机损坏 → 硬件故障中断（需要维修）

---

#### 5. 访管中断（系统调用）⭐⭐⭐（重要）

**定义**：用户程序请求操作系统服务时产生的中断

```mermaid
graph TB
    A[访管中断 SVC<br/>Supervisor Call] --> B[触发场景]
    A --> C[状态切换]

    B --> B1[打开文件]
    B --> B2[网络通信]
    B --> B3[创建进程]
    B --> B4[分配内存]

    C --> C1[用户态<br/>User Mode]
    C --> C2[内核态<br/>Kernel Mode]

    C1 -.系统调用.-> C2
    C2 -.返回.-> C1

    D[本质] --> E[从用户态切换到<br/>内核态的机制]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style C1 fill:#fcf,stroke:#333,stroke-width:2px
    style C2 fill:#fcc,stroke:#333,stroke-width:2px
```

---

### 用户态 vs 内核态 ⭐⭐

```mermaid
graph TB
    A[用户态 vs 内核态] --> B[用户态<br/>User Mode]
    A --> C[内核态<br/>Kernel Mode<br/>系统态]

    B --> B1[权限：受限]
    B --> B2[运行：用户程序]
    B --> B3[能力：不能直接<br/>访问硬件]

    C --> C1[权限：完全]
    C --> C2[运行：操作系统<br/>核心代码]
    C --> C3[能力：可以访问<br/>所有资源]

    D[切换时机] --> E[系统调用<br/>访管中断]
    D --> F[中断/异常]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style B fill:#fcf,stroke:#333,stroke-width:2px
    style C fill:#fcc,stroke:#333,stroke-width:2px
```

**为什么需要两种状态？**

```mermaid
graph LR
    A[用户态与内核态<br/>存在的意义] --> B[安全性]
    A --> C[稳定性]

    B --> B1[防止用户程序<br/>直接操作硬件]
    B --> B2[保护系统资源]

    C --> C1[隔离用户程序<br/>和操作系统]
    C --> C2[避免误操作<br/>导致系统崩溃]

    style A fill:#f9f,stroke:#333,stroke-width:3px
```

> **形象比喻**：
> - 用户态 = 普通员工（只能使用基本设施）
> - 内核态 = 管理员（拥有所有权限）
> - 系统调用 = 向管理员申请特殊权限

---

### 内核架构：单体内核 vs 微内核 ⭐

```mermaid
graph TB
    A[操作系统内核架构] --> B[单体内核<br/>Monolithic Kernel]
    A --> C[微内核<br/>Microkernel]

    B --> B1[特点：内核功能多<br/>集成度高]
    B --> B2[优点：性能高<br/>调用快]
    B --> B3[缺点：维护复杂<br/>稳定性差]
    B --> B4[代表：Linux<br/>Unix]

    C --> C1[特点：内核功能少<br/>只保留核心]
    C --> C2[优点：稳定性好<br/>易维护]
    C --> C3[缺点：性能相对低<br/>通信开销大]
    C --> C4[代表：Mach<br/>QNX]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style B fill:#fcf,stroke:#333,stroke-width:2px
    style C fill:#cfc,stroke:#333,stroke-width:2px
```

**对比表**：

| 特性 | 单体内核 | 微内核 |
|------|---------|--------|
| **内核大小** | 大（功能多） | 小（功能少）⭐ |
| **性能** | 高（直接调用） | 相对低（通信开销） |
| **稳定性** | 低（牵一发动全身） | 高（模块独立）⭐ |
| **维护性** | 复杂 | 简单 ⭐ |
| **扩展性** | 困难 | 容易 |
| **典型系统** | Linux, Unix, Windows | Mach, QNX, L4 |

---

### 中断机制的重要性

```mermaid
graph TB
    A[中断机制的作用] --> B[提高CPU利用率]
    A --> C[实现进程并发]
    A --> D[快速响应事件]
    A --> E[实现设备管理]

    B --> B1[CPU不必等待<br/>慢速设备]

    C --> C1[多进程切换的<br/>基础机制]

    D --> D1[紧急事件<br/>优先处理]

    E --> E1[设备完成通知CPU]

    style A fill:#f9f,stroke:#333,stroke-width:3px
```

> **关键理解**：中断机制是操作系统实现多任务、并发执行的核心机制之一。

---

## 💡 学习建议

### 本部分学习重点

1. **⭐⭐⭐ 必须掌握**（必考内容）：
   - 进程三态图及状态转换规则
   - 进程资源图的分析和死锁判断
   - PV操作的原理和应用
   - 生产者-消费者问题
   - 进程调度算法

2. **⭐⭐ 重点理解**（高频考点）：
   - 前驱图与PV操作的转换
   - 多级反馈调度
   - 进程 vs 线程的区别
   - 中断的五种分类
   - 用户态 vs 内核态

3. **⭐ 了解层面**（偶尔考到）：
   - 三级调度
   - 单体内核 vs 微内核

---

### 考试题型预测

| 知识点 | 题型 | 分值 | 难度 | 频率 |
|-------|------|------|------|------|
| 进程三态图 | 选择/填空 | 2分 | ⭐⭐ | 很高 |
| 进程资源图与死锁 | 综合题 | 3-4分 | ⭐⭐⭐ | 很高 |
| PV操作 | 选择/填空 | 2-3分 | ⭐⭐⭐ | 很高 |
| 生产者-消费者 | 综合题 | 4-5分 | ⭐⭐⭐ | 高 |
| 前驱图 | 填空题 | 2-3分 | ⭐⭐ | 中 |
| 进程调度算法 | 选择/计算 | 2-3分 | ⭐⭐ | 中 |

---

### 记忆技巧

1. **进程三态**：运行（什么都不缺）、就绪（只缺CPU）、阻塞（啥都缺）
2. **PV操作**：P减申请、V加释放
3. **调度算法**：FCFS（先来）、优先级（高低）、轮转（公平）、多级反馈（综合）
4. **进程vs线程**：进程拥有资源，线程负责调度
5. **中断五类**：程序（代码错）、外部（强制停）、IO（设备事）、硬件（真故障）、访管（系统调用）
6. **内核架构**：单体（大而全）、微内核（小而精）

---

## ✅ 自测题

### 选择题

1. 进程从运行态转换到阻塞态的原因是？
   - A. 时间片用完
   - B. 等待某个IO事件 ✓
   - C. 被调度器选中
   - D. 进程优先级降低

2. 以下哪个状态转换是不可能的？
   - A. 运行态 → 就绪态
   - B. 就绪态 → 运行态
   - C. 就绪态 → 阻塞态 ✓
   - D. 阻塞态 → 就绪态

3. 互斥信号量的初值一般设置为？
   - A. 0
   - B. 1 ✓
   - C. 资源数量
   - D. 进程数量

4. 在生产者-消费者问题中，生产者执行P(S1)的含义是？
   - A. 申请仓库使用权
   - B. 申请一个空位 ✓
   - C. 申请一个商品
   - D. 释放一个空位

5. 引入线程后，以下说法正确的是？
   - A. 线程是拥有资源的基本单位
   - B. 线程是独立调度的基本单位 ✓
   - C. 线程拥有独立的资源空间
   - D. 进程是独立调度的基本单位

6. 以下哪种中断类型是由程序错误引起的？
   - A. 外中断
   - B. 程序性中断 ✓
   - C. 访管中断
   - D. 输入输出中断

7. 打印机缺纸属于哪种中断类型？
   - A. 硬件故障中断
   - B. 输入输出中断 ✓
   - C. 外中断
   - D. 程序性中断

8. 用户程序调用系统函数打开文件时，会产生什么中断？
   - A. 程序性中断
   - B. 外中断
   - C. 访管中断（系统调用）✓
   - D. 输入输出中断

---

### 简答题

1. **请说明进程三态转换的4种情况及其触发条件。**

<details>
<summary>点击查看答案</summary>

- **运行态 → 就绪态**：时间片用完
- **就绪态 → 运行态**：被调度器选中
- **运行态 → 阻塞态**：等待IO事件
- **阻塞态 → 就绪态**：等待的事件发生

**不可能的转换**：
- 就绪态 → 阻塞态（原因：两者都没有CPU）
- 阻塞态 → 运行态（原因：必须先排队）

</details>

---

2. **什么是阻塞节点？如何判断进程资源图中的阻塞节点？**

<details>
<summary>点击查看答案</summary>

**阻塞节点的定义**：
- 进程请求一个当前系统中没有剩余的资源
- 不可能得到该资源

**判断方法**：
1. 计算资源剩余数量 = 总数 - 已分配数量
2. 查看进程请求的资源数量
3. 如果请求数量 > 剩余数量 → 阻塞节点
4. 如果请求数量 <= 剩余数量 → 非阻塞节点

**注意**：
- 多个进程请求同一个剩余资源时，都是非阻塞节点
- 因为调度器可以选择满足其中任何一个

</details>

---

3. **为什么V操作中要判断S <= 0，而不是S < 0？**

<details>
<summary>点击查看答案</summary>

**原因**：

假设当前S = -2（有2个进程在排队）

执行V操作：
1. S = S + 1 = -2 + 1 = -1
2. 判断：S = -1，仍然 <= 0
3. 说明：还有1个进程在排队等待
4. 操作：应该唤醒队列中的一个进程

**总结**：
- S <= 0 表示有进程在排队
- 释放资源后应优先给排队的进程
- 如果S > 0，说明没有进程排队，资源放回资源池

</details>

---

4. **请说明进程和线程的主要区别。**

<details>
<summary>点击查看答案</summary>

**核心区别**：

1. **调度单位的变化**：
   - 传统进程：既拥有资源，又是调度单位
   - 引入线程后：进程只拥有资源，线程成为调度单位 ⭐

2. **资源拥有关系**：
   - 进程：拥有独立的资源空间
   - 线程：不拥有资源，与同进程的其他线程共享进程资源

3. **线程共享的资源**：
   - 公共数据
   - 全局变量
   - 代码段
   - 文件数据

4. **线程独有的资源**：
   - 线程ID（标识）
   - 程序计数器（PC）
   - 寄存器组
   - 栈（Stack）
   - 线程控制块（TCB）

**对比表**：

| 特性 | 进程 | 线程 |
|------|------|------|
| 资源拥有 | 拥有独立资源 | 共享进程资源 |
| 调度 | 传统上是调度单位 | 现代系统的调度单位 ⭐ |
| 开销 | 创建和切换开销大 | 创建和切换开销小 |
| 通信 | 进程间通信复杂 | 线程间通信简单 |
| 崩溃影响 | 互不影响 | 可能导致整个进程崩溃 |

**记忆口诀**：进程拥有资源，线程负责调度

</details>

---

5. **请说明中断的五种分类及其区别。**

<details>
<summary>点击查看答案</summary>

**中断的五种分类**：

1. **程序性中断**：
   - 原因：程序代码错误或特定状态
   - 举例：内存越界、除零错误、段错误（Core Dump）
   - 特点：由程序自身引起

2. **外中断**：
   - 原因：外部事件触发
   - 举例：时钟中断、Ctrl+C强制终止、操作员控制台中断
   - 特点：外部强制触发，与当前进程无关

3. **输入输出中断**：
   - 原因：外设操作完成或异常
   - 举例：打印机缺纸、磁盘读取完成、网络数据到达
   - 特点：设备相关，但不一定是故障

4. **硬件故障中断**：
   - 原因：硬件真正出现故障
   - 举例：电源故障、内存故障、硬件损坏
   - 特点：真正的硬件损坏，需要维修

5. **访管中断（系统调用）**：
   - 原因：用户程序请求操作系统服务
   - 举例：打开文件、网络通信、创建进程
   - 特点：从用户态切换到内核态的机制 ⭐

**区分要点**：
- I/O中断 vs 硬件故障中断：
  - 打印机缺纸 → I/O中断（可以补充解决）
  - 打印机损坏 → 硬件故障中断（需要维修）

**记忆口诀**：程序（代码错）、外部（强制停）、IO（设备事）、硬件（真故障）、访管（系统调用）

</details>

---

6. **请说明用户态和内核态的区别及切换时机。**

<details>
<summary>点击查看答案</summary>

**用户态 vs 内核态**：

| 特性 | 用户态（User Mode） | 内核态（Kernel Mode） |
|------|-------------------|---------------------|
| **权限** | 受限 | 完全权限 |
| **运行内容** | 用户程序 | 操作系统核心代码 |
| **访问能力** | 不能直接访问硬件 | 可以访问所有资源 |
| **安全性** | 隔离保护 | 完全控制 |

**为什么需要两种状态？**

1. **安全性**：
   - 防止用户程序直接操作硬件
   - 保护系统资源不被误操作

2. **稳定性**：
   - 隔离用户程序和操作系统
   - 避免用户程序错误导致系统崩溃

**切换时机**：

1. **用户态 → 内核态**：
   - 系统调用（访管中断）
   - 中断发生
   - 异常/错误发生

2. **内核态 → 用户态**：
   - 系统调用返回
   - 中断处理完成
   - 进程调度（切换到用户进程）

**形象比喻**：
- 用户态 = 普通员工（只能使用基本设施）
- 内核态 = 管理员（拥有所有权限）
- 系统调用 = 向管理员申请特殊权限

</details>

---

### 综合题

**题目**：现有系统中资源R1有2个，资源R2有1个。进程P1持有R1(1个)，请求R2(1个)；进程P2持有R2(1个)，请求R1(1个)。请问：

1. 画出进程资源图
2. 判断P1、P2是否为阻塞节点
3. 判断系统是否处于死锁状态

<details>
<summary>点击查看答案</summary>

**1. 进程资源图**（用Mermaid绘制）：

```mermaid
graph LR
    R1[R1资源<br/>总数:2个]
    R2[R2资源<br/>总数:1个]

    P1((P1进程))
    P2((P2进程))

    R1 -->|已分配1个| P1
    P1 -->|请求1个| R2

    R2 -->|已分配1个| P2
    P2 -->|请求1个| R1
```

**2. 判断阻塞节点**：

- **R1分析**：
  - 总数：2个
  - 已分配：1个（给P1）
  - 剩余：1个

- **R2分析**：
  - 总数：1个
  - 已分配：1个（给P2）
  - 剩余：0个

- **P1分析**：
  - 请求R2：1个
  - R2剩余：0个
  - **结论：P1是阻塞节点**

- **P2分析**：
  - 请求R1：1个
  - R1剩余：1个
  - **结论：P2是非阻塞节点**

**3. 是否死锁**：

尝试化简：
1. P2是非阻塞节点，可以运行
2. P2运行完释放R2(1个)
3. P1变成非阻塞节点
4. P1可以运行完

**结论**：系统不是死锁状态 ✅

</details>

---

## 📚 相关文档

- **上一部分**：[第二章-1-操作系统概述](./第二章-1-操作系统概述.md) ⭐⭐
- **扩展阅读**：《操作系统概念》第3-5章

---

## 📝 本部分总结

本部分作为操作系统的**核心考点章节**，主要介绍了：

1. **进程基本概念**：进程 = 运行中的程序，由PCB + 程序段 + 数据段组成
2. **进程三态图**（⭐⭐⭐必考）：运行态、就绪态、阻塞态及状态转换规则
3. **进程资源图与死锁检测**（⭐⭐⭐必考）：阻塞节点判断、系统化简
4. **进程同步与互斥**（⭐⭐⭐必考）：PV操作、信号量含义
5. **生产者-消费者问题**（⭐⭐⭐经典案例）：完整代码实现
6. **前驱图**（⭐⭐）：与PV操作的转换关系
7. **进程调度算法**（⭐⭐⭐）：FCFS、优先级、时间片轮转、多级反馈

**考试分值**：本部分内容在考试中占2-4分，是操作系统的核心内容。

**重点掌握**：进程三态图、进程资源图与死锁、PV操作、生产者-消费者问题。

---

> **文档生成信息**
> 📅 生成时间：2026-02-05
> 🤖 生成方式：基于思维导图、课程文稿、PDF系统化梳理（Mermaid图解版）
> 📖 适用对象：软考高级系统架构师考试备考
> ✍️ 建议：反复练习真题，重点掌握PV操作和死锁检测
> 🎨 图形工具：使用Mermaid绘制，支持在线预览和导出
