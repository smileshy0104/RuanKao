# 第一章 计算机系统基础知识（线性图解版）

> **📌 学习指南**
> 本章是软考高级系统架构师的基础章节，虽然直接考点不多（约5-8分），但是理解后续章节的基石。
> **学习建议**：理解为主，记忆为辅，重点掌握概念和分类。

---

## 📖 本章知识体系（线性结构）

```
第一章 计算机系统基础知识
│
├── 第一部分：计算机系统概述 ⭐
│   ├── 计算机系统 = 硬件 + 软件 + 网络
│   └── 冯诺依曼五大部件
│
├── 第二部分：计算机硬件 ⭐⭐
│   ├── 2.1 处理器（CPU）
│   │   ├── CISC vs RISC ⭐⭐⭐（必考）
│   │   └── GPU/DSP/FPGA
│   ├── 2.2 存储器 ⭐⭐
│   │   └── 四层结构：L1→L2→主存→外存
│   ├── 2.3 总线 ⭐⭐⭐
│   │   ├── 按位置：内总线→系统总线→外总线
│   │   ├── 系统总线三类：控制/地址/数据（必考）
│   │   └── 按方式：串行 vs 并行
│   └── 2.4 接口
│
├── 第三部分：计算机软件 ⭐⭐⭐
│   ├── 3.1 软件分类
│   │   ├── 系统软件（操作系统、数据库等）
│   │   └── 应用软件
│   └── 3.2 文件系统 ⭐⭐⭐（重点！）
│       ├── 文件结构
│       │   ├── 逻辑结构：记录式 vs 流式
│       │   └── 物理结构：顺序/链接/索引（必考）
│       ├── 空闲空间管理
│       │   └── 位示图计算 ⭐⭐⭐（必考计算题）
│       ├── 文件共享
│       │   └── 硬链接 vs 软链接 ⭐⭐
│       └── 访问控制
│           └── Linux权限（rwx = 421）⭐⭐
│
├── 第四部分：中间件 ⭐
│   └── 8大类型（消息、事务、数据、Web等）
│
└── 第五部分：软件构建 ⭐⭐
    ├── 基于构建的开发（组装式）
    └── 商用标准
        ├── CORBA（三层架构）⭐⭐
        ├── J2EE（Servlet+EJB）
        └── DNA（COM/DCOM）
```

**考试重要程度**：
- ⭐ = 了解即可（选择题可能涉及）
- ⭐⭐ = 理解掌握（选择题常考）
- ⭐⭐⭐ = 重点掌握（选择题+案例分析）

---

## 第一部分：计算机系统概述 ⭐

### 1.1 计算机系统的组成

```
计算机系统
    ↓
    ├─ 硬件层（看得见摸得着）
    │   ├─ CPU（大脑）
    │   ├─ 内存（工作台）
    │   ├─ 硬盘（仓库）
    │   └─ 输入输出设备（手、眼、嘴）
    │
    ├─ 软件层（看不见的程序）
    │   ├─ 操作系统（管家）
    │   └─ 应用软件（工具箱）
    │
    └─ 网络层（连接外部世界）
        ├─ 互联网
        └─ 局域网
```

**核心理解**：计算机系统 = 硬件 + 软件 + 网络

---

### 1.2 冯·诺依曼五大部件 ⭐

```
输入设备 ──→ 中央处理器CPU ──→ 输出设备
              ├─ 控制器（指挥中心）
              └─ 运算器（计算中心）
                    ↕
                 存储器
              ├─ 内存（易失）
              └─ 外存（非易失）
```

**五大部件详解表**：

| 序号 | 部件 | 英文名 | 通俗比喻 | 主要功能 |
|------|------|--------|---------|---------|
| 1 | **控制器** | Controller | 公司CEO | 发出指令，协调各部件工作 |
| 2 | **运算器** | ALU | 财务部门 | 进行算术运算和逻辑运算 |
| 3 | **存储器** | Memory | 办公室+仓库 | 存储数据和程序（内存+硬盘） |
| 4 | **输入设备** | Input Device | 员工的眼睛和耳朵 | 向计算机输入信息（键盘、鼠标） |
| 5 | **输出设备** | Output Device | 员工的嘴和手 | 显示计算结果（显示器、打印机） |

> **💡 记忆口诀**：控运存输输（控制、运算、存储、输入、输出）
> **🔑 核心公式**：**控制器 + 运算器 = CPU**（中央处理单元）

---

## 第二部分：计算机硬件

### 2.1 处理器（CPU）⭐⭐

#### 2.1.1 指令集对比：CISC vs RISC ⭐⭐⭐（必考！）

**什么是指令集？** CPU能听懂的命令集合，就像人类的语言。

```
CPU指令集
    │
    ├─ CISC（复杂指令集）
    │   ├─ 指令长度：不固定（1-15字节）
    │   ├─ 指令数量：多（200-300条）
    │   ├─ 执行时间：长（多个时钟周期）
    │   ├─ 实现方式：微程序控制（软件）⭐⭐⭐
    │   ├─ 寄存器：较少
    │   ├─ 代表产品：Intel x86（台式机/笔记本）
    │   ├─ 优点：功能强大，兼容性好
    │   └─ 缺点：复杂，功耗高
    │
    └─ RISC（精简指令集）
        ├─ 指令长度：固定（通常4字节）
        ├─ 指令数量：少（50-100条）
        ├─ 执行时间：短（单个时钟周期）
        ├─ 实现方式：硬布线逻辑（硬件）⭐⭐⭐
        ├─ 寄存器：大量使用
        ├─ 代表产品：ARM（手机/平板）
        ├─ 优点：速度快，功耗低
        └─ 缺点：需要编译器优化
```

**核心对比表**：

| 对比维度 | CISC（复杂） | RISC（精简） |
|---------|-------------|-------------|
| **设计思想** | 一条指令做很多事 | 一条指令只做一件事 |
| **指令长度** | 不定长 | 定长 |
| **指令数量** | 多（200-300条） | 少（50-100条） |
| **执行周期** | 多个时钟周期 | 单个时钟周期 |
| **⭐实现方式⭐** | **微程序控制**（软件）| **硬布线逻辑**（硬件） |
| **寄存器** | 较少 | 大量使用 |
| **代表产品** | Intel x86 | ARM、MIPS |

> **🎯 考试必记**：
> - CISC用**微程序控制**（软件实现）
> - RISC用**硬布线逻辑**（硬件实现，大量寄存器）

**🌰 生活化例子**：
- **CISC** = 瑞士军刀（功能多，能干很多事，但笨重）
- **RISC** = 专业工具（每个工具只干一件事，但很快）

---

#### 2.1.2 其他处理器类型

```
处理器芯片类型
    │
    ├─ CPU（通用计算）
    │   └─ 代表：Intel Core、AMD Ryzen
    │
    ├─ GPU（图形处理）
    │   ├─ 代表：NVIDIA、AMD Radeon
    │   └─ 用途：游戏、3D渲染、AI训练
    │
    ├─ DSP（数字信号处理）
    │   ├─ 用途：通信、雷达、军工、航天
    │   ├─ 特点：采用哈佛架构（与冯诺依曼不同）
    │   └─ 速度：比CPU快10-15倍
    │
    └─ FPGA（现场可编程）
        └─ 用途：嵌入式、开发板、原型设计
```

**🔥 为什么GPU这么火？**
- 传统用途：玩游戏、渲染3D画面
- 现代用途：训练AI模型（ChatGPT）、挖比特币、科学计算
- 原因：GPU有成百上千个小核心，适合大量重复的简单计算

---

### 2.2 存储器：四层金字塔 ⭐⭐

**核心原则**：离CPU越近 → 速度越快、容量越小、价格越贵！

```
存储器层次（从快到慢）
    │
    ↓ 最快、最小、最贵
    ├─ 第1层：片上缓存（L1 Cache）
    │   ├─ 位置：CPU芯片内部
    │   ├─ 容量：16KB ~ 512KB
    │   ├─ 速度：最快（0.5ns）
    │   ├─ 材料：SRAM（静态RAM）
    │   └─ 易失性：易失（断电丢失）
    │
    ↓
    ├─ 第2层：片外缓存（L2/L3 Cache）
    │   ├─ 位置：CPU芯片外部
    │   ├─ 容量：256KB ~ 4MB
    │   ├─ 速度：很快（7ns）
    │   ├─ 材料：SRAM（静态RAM）
    │   └─ 易失性：易失（断电丢失）
    │
    ↓
    ├─ 第3层：主存（内存RAM）
    │   ├─ 位置：主板上
    │   ├─ 容量：8GB ~ 64GB
    │   ├─ 速度：中速（100ns）
    │   ├─ 材料：DRAM（动态RAM，需刷新）
    │   └─ 易失性：易失（断电丢失）
    │
    ↓ 最慢、最大、最便宜
    └─ 第4层：外存（硬盘/SSD）
        ├─ 位置：独立设备
        ├─ 容量：512GB ~ 4TB
        ├─ 速度：慢（毫秒级）
        ├─ 材料：磁盘/闪存Flash
        └─ 易失性：非易失（断电不丢失）
```

**🌰 生活化比喻**：

想象你在图书馆写作业：

```
L1缓存 = 你脑子里记住的内容（最快，但很少）
    ↓
L2/L3缓存 = 你桌子上的书（翻一下就能看，但桌子很小）
    ↓
内存RAM = 你借的书在书包里（走几步拿出来，容量一般）
    ↓
外存硬盘 = 图书馆的书架（要去找很久，但能存海量的书）
```

**关键知识点**：

1. **SRAM vs DRAM**：
   ```
   SRAM（静态RAM）
       ├─ 速度快（不需要刷新）
       ├─ 价格贵
       └─ 用途：缓存（L1/L2/L3）

   DRAM（动态RAM）
       ├─ 需要不断刷新（否则数据丢失）
       ├─ 价格便宜
       └─ 用途：内存
   ```

2. **为什么32位系统只支持4GB内存？**
   ```
   原因：地址总线是32位
       ↓
   可寻址空间 = 2³² 个地址
                = 4,294,967,296 字节
                = 4GB

   64位系统理论上可以支持：
       2⁶⁴ = 16EB（1EB = 100万TB）
   ```

---

### 2.3 总线：计算机的"高速公路" ⭐⭐⭐

#### 2.3.1 按位置分类

```
总线分类（按位置）
    │
    ├─ 内总线（片内/片上总线）
    │   ├─ 位置：CPU芯片内部
    │   └─ 可见性：看不到
    │
    ├─ 系统总线（局部总线）⭐⭐⭐ 重点！
    │   ├─ 位置：主板上各设备间
    │   ├─ 可见性：拆开电脑能看到
    │   ├─ 典型：PCI总线
    │   └─ 细分为三类：
    │       ├─ 控制总线（传递控制信号）
    │       ├─ 地址总线（传递地址信息）
    │       └─ 数据总线（传递实际数据）
    │
    └─ 外部总线（通信总线）
        ├─ 位置：计算机外部
        ├─ 可见性：能看到和摸到
        └─ 典型：USB、HDMI
```

**🎯 考试重点：系统总线的三种类型**（⭐⭐⭐ 必考）

```
系统总线
    │
    ├─ 控制总线（Control Bus）
    │   ├─ 作用：传递控制命令和状态信号
    │   └─ 例如："读取数据"、"写入数据"、"中断请求"
    │
    ├─ 地址总线（Address Bus）⭐
    │   ├─ 作用：传递内存或I/O设备的地址
    │   ├─ 例如："从内存地址0x1000读数据"
    │   └─ 宽度决定最大内存：
    │       ├─ 32位地址总线 → 最多4GB内存
    │       └─ 64位地址总线 → 最多16EB内存
    │
    └─ 数据总线（Data Bus）
        ├─ 作用：传递实际的数据
        ├─ 例如：传输数字、文字、图片等数据
        └─ 宽度决定传输速度：
            ├─ 32位数据总线 → 每次传输4字节
            └─ 64位数据总线 → 每次传输8字节
```

**🌰 生活化例子**：就像快递系统

```
控制总线 = 快递单上的"加急"、"签收"等指令
    ↓
地址总线 = 收货地址（决定能送到哪里）
    ↓
数据总线 = 快递车（决定一次能运多少货）
```

---

#### 2.3.2 按传输方式分类

```
按传输方式分类
    │
    ├─ 串行总线（Serial Bus）
    │   ├─ 特点：一根线，逐比特传输
    │   ├─ 优点：成本低，适合远距离
    │   ├─ 缺点：速度慢（但现代技术已克服）
    │   └─ 例子：
    │       ├─ USB（U盘、键盘、鼠标）
    │       ├─ SATA（硬盘接口）
    │       ├─ CAN（汽车电子）
    │       └─ RS-232（老式串口）
    │
    └─ 并行总线（Parallel Bus）
        ├─ 特点：多根线，多比特同时传输
        ├─ 优点：速度快（理论上）
        ├─ 缺点：成本高，适合短距离，有信号同步问题
        └─ 例子：
            ├─ PCI（主板扩展槽）
            └─ IDE（老式硬盘接口，已淘汰）
```

**常见总线速度对照表**：

| 总线名称 | 类型 | 位置 | 主要用途 | 传输速度 |
|---------|------|------|---------|---------|
| USB 2.0 | 串行 | 外部 | 键盘、鼠标、U盘 | 480 Mbps |
| USB 3.0 | 串行 | 外部 | 移动硬盘、高速U盘 | 5 Gbps |
| USB 3.1 | 串行 | 外部 | 高速设备 | 10 Gbps |
| SATA 3 | 串行 | 内部 | 硬盘、SSD | 6 Gbps |
| PCI | 并行 | 内部 | 显卡、网卡 | 133-533 MB/s |
| PCIe 4.0 x16 | 串行 | 内部 | 高速显卡、SSD | 32 GB/s |
| HDMI | 串行 | 外部 | 显示器、电视 | 18 Gbps（4K@60Hz）|
| RJ-45 | 串行 | 外部 | 网络连接 | 1 Gbps（千兆网） |

> **🤔 为什么现在串行总线更流行？**
> - 并行总线有**信号同步问题**（不同线的信号到达时间不一致）
> - 串行总线**抗干扰能力强**，可以跑更高的频率
> - 串行总线**成本低**，布线简单
> - 所以现代高速总线（USB 3.0、SATA 3、PCIe）都是串行的！

---

### 2.4 接口：总线的"车站" ⭐

```
接口 vs 总线
    │
    ├─ 总线 = 道路（数据传输通道）
    └─ 接口 = 车站（设备连接点）

一一对应关系：
    USB总线 ↔ USB接口
    SATA总线 ↔ SATA接口
    HDMI总线 ↔ HDMI接口
```

**常见接口分类**：

```
计算机接口
    │
    ├─ 外部接口（看得见摸得着）
    │   ├─ USB接口（Type-A方形、Type-C椭圆可正反插）
    │   ├─ HDMI/DVI接口（视频输出，梯形）
    │   ├─ TRS/RCA/XLR接口（音频，圆形插孔）
    │   ├─ RJ-45接口（网络，方形8针）
    │   └─ PS/2接口（老式键盘鼠标，圆形）
    │
    └─ 内部接口（需要拆机才能看到）
        ├─ SATA接口（硬盘连接，扁平7针）
        └─ PCI/PCIe接口（显卡、网卡扩展槽）
```

---

## 第三部分：计算机软件

### 3.1 软件分类：系统软件 vs 应用软件 ⭐

```
计算机软件
    │
    ├─ 系统软件（System Software）
    │   ├─ 操作系统 ⭐⭐⭐
    │   │   └─ Windows、Linux、macOS
    │   ├─ 编译器
    │   │   └─ GCC、Clang、MSVC
    │   ├─ 数据库管理系统 ⭐⭐⭐
    │   │   └─ MySQL、Oracle、PostgreSQL
    │   └─ 翻译工具
    │       └─ 解释器、汇编器
    │
    └─ 应用软件（Application Software）
        ├─ 办公软件
        │   └─ Word、Excel、PowerPoint
        ├─ 娱乐软件
        │   └─ 游戏、音乐、视频播放器
        └─ 业务系统
            └─ ERP、CRM、财务系统
```

**核心区别表**：

| 对比项 | 系统软件 | 应用软件 |
|-------|---------|---------|
| **依赖性** | 不依赖特定应用领域 | 针对特定问题和领域 |
| **通用性** | 通用，所有计算机都需要 | 专用，根据需求选择 |
| **主要功能** | 管理和控制硬件和软件资源 | 解决特定的业务问题 |
| **典型代表** | 操作系统、编译器、数据库 | Office、微信、游戏 |
| **用户** | 面向开发者和管理员 | 面向最终用户 |

---

### 3.2 文件系统 ⭐⭐⭐（重点章节！）

#### 3.2.1 文件的基本概念

```
文件（File）
    │
    ├─ 定义：一组相关信息的集合
    │
    └─ 组成：
        ├─ 文件体（内容）
        │   └─ 文件实际存储的数据
        │
        └─ 文件说明（元数据）
            ├─ 文件名
            ├─ 文件类型/扩展名（.txt、.jpg、.exe）
            ├─ 文件大小
            ├─ 创建时间、修改时间、访问时间
            ├─ 访问权限（可读/可写/可执行）
            └─ 物理存储位置
```

---

#### 3.2.2 文件类型分类

```
文件类型
    │
    ├─ 按性质和用途
    │   ├─ 系统文件
    │   ├─ 库文件
    │   └─ 用户文件
    │
    ├─ 按保存期限
    │   ├─ 临时文件
    │   ├─ 档案文件
    │   └─ 永久文件
    │
    ├─ 按保护方式 ⭐⭐
    │   ├─ 只读文件（r）
    │   ├─ 可写文件（w）
    │   └─ 可执行文件（x）
    │
    └─ 按操作系统分类（Unix/Linux）
        ├─ 普通文件（-）
        ├─ 目录文件（d）
        ├─ 设备文件（c字符设备，b块设备）
        ├─ 链接文件（l）
        └─ 套接字（s）
```

---

#### 3.2.3 文件结构 ⭐⭐⭐（必考！）

文件有两种结构视角：

##### （1）逻辑结构（用户视角）

```
文件逻辑结构
    │
    ├─ 有结构的记录式文件
    │   ├─ 特点：由固定或可变长度的记录组成
    │   ├─ 例子：
    │   │   ├─ Excel表格（每个单元格/行是一个记录）
    │   │   └─ 数据库表（每行是一个记录）
    │   └─ 访问：可以按记录访问
    │
    └─ 无结构的流式文件
        ├─ 特点：字节流形式，无固定记录
        ├─ 例子：
        │   ├─ 文本文件（.txt）
        │   └─ 日志文件（.log）
        └─ 访问：按字节流顺序访问
```

**🌰 生活化例子**：
- **记录式文件** = 表格本（有格子，每个格子是一个记录）
- **流式文件** = 白纸（连续的内容，没有固定格式）

---

##### （2）物理结构 ⭐⭐⭐（重点考点！）

```
文件物理结构（存储方式）
    │
    ├─ 1. 顺序结构（连续结构）
    │   ├─ 原理：逻辑相邻=物理相邻
    │   ├─ 优点：
    │   │   ├─ 访问速度快
    │   │   └─ 顺序和随机访问都快
    │   ├─ 缺点：
    │   │   ├─ 容易产生碎片
    │   │   └─ 文件增长困难
    │   └─ 适用场景：文件大小固定
    │
    ├─ 2. 链接结构（链表结构）
    │   ├─ 原理：用指针链接各个数据块
    │   ├─ 优点：
    │   │   ├─ 灵活，易于增删
    │   │   └─ 不会产生碎片
    │   ├─ 缺点：
    │   │   ├─ 只能顺序访问
    │   │   └─ 需要额外空间存指针
    │   └─ 适用场景：文件频繁增删
    │
    ├─ 3. 索引结构（目录结构）⭐
    │   ├─ 原理：建立索引表，记录数据块位置
    │   ├─ 优点：
    │   │   ├─ 快速随机访问
    │   │   └─ 支持大文件
    │   ├─ 缺点：
    │   │   └─ 需要额外空间存索引
    │   └─ 适用场景：大文件，频繁随机访问
    │
    └─ 4. 多级索引结构
        ├─ 原理：多层索引+链接组合
        ├─ 优点：综合以上优点
        ├─ 缺点：实现复杂
        └─ 适用场景：超大文件
```

**详细对比表**：

| 物理结构 | 原理 | 优点 | 缺点 | 适用场景 |
|---------|------|------|------|---------|
| 顺序 | 逻辑相邻=物理相邻 | 访问速度快 | 产生碎片，难扩展 | 文件大小固定 |
| 链接 | 用指针链接各块 | 灵活，无碎片 | 只能顺序访问 | 频繁增删 |
| 索引 | 建立索引表 | 快速随机访问 | 需要额外空间 | 大文件，随机访问 |
| 多级索引 | 多层索引+链接 | 综合优点 | 复杂 | 超大文件 |

**🌰 生活化例子**：

```
顺序结构 = 排队买票
    └─ 按顺序排，效率高，但插队很难

链接结构 = 火车车厢
    └─ 每节车厢挂钩连到下一节，可以随时加车厢

索引结构 = 图书馆目录卡
    └─ 先查目录，再去书架拿书

多级索引 = 超市导航
    └─ 先看楼层指南，再看区域指南，再找具体货架
```

---

#### 3.2.4 文件存取方式

```
文件存取方式
    │
    ├─ 顺序存取（Sequential Access）
    │   ├─ 特点：从头到尾按顺序读写
    │   └─ 应用：日志文件、磁带备份
    │
    └─ 随机存取（Random Access）
        ├─ 特点：可以直接访问任意位置
        └─ 应用：数据库文件、程序文件
```

---

#### 3.2.5 空闲空间管理 ⭐⭐⭐（必考计算题！）

**问题**：硬盘上哪些块是空闲的？如何快速找到空闲块？

```
空闲空间管理方法
    │
    ├─ 1. 空闲区表法
    │   ├─ 适用：连续空闲块
    │   └─ 原理：记录起始块号和块数
    │       例如：物理块 5-15 是空闲的
    │       空闲区表：| 起始块号:5 | 块数:11 |
    │
    ├─ 2. 位示图法 ⭐⭐⭐（必考！）
    │   ├─ 原理：用1个比特表示1个物理块
    │   │   ├─ 0 = 空闲
    │   │   └─ 1 = 占用
    │   ├─ 优点：查找快，占用空间小
    │   └─ 计算公式：⭐⭐⭐
    │       ├─ 位示图大小（bit）= 物理块总数
    │       ├─ 位示图大小（字节）= 物理块总数 ÷ 8
    │       ├─ 字节号 = 物理块号 ÷ 8
    │       └─ 位号 = 物理块号 % 8
    │
    ├─ 3. 空闲块链法
    │   ├─ 适用：不连续空闲块
    │   └─ 原理：用指针链接所有空闲块
    │
    └─ 4. 成组链接法
        ├─ 适用：Unix系统
        └─ 原理：空闲区表 + 空闲块链的组合
```

**💯 考试必考：位示图计算题**

**题型1：计算位示图大小**

```
📝 例题1：
某磁盘有10,000个物理块，采用位示图管理空闲空间，
计算位示图需要占用多少字节的存储空间？

解答步骤：
1. 位示图大小（bit）= 物理块总数
   = 10,000 bit

2. 位示图大小（字节）= 10,000 ÷ 8
   = 1,250 字节

3. 转换为KB = 1,250 ÷ 1024
   ≈ 1.22 KB

答案：1,250字节（或1.22KB）
```

```
📝 例题2：
某磁盘容量100GB，物理块大小4KB，采用位示图管理。
(1) 计算磁盘总共有多少个物理块？
(2) 位示图需要占用多少MB的存储空间？

解答步骤：
(1) 计算物理块总数
    100GB = 100 × 1024 × 1024 × 1024 字节
    4KB = 4 × 1024 字节

    物理块总数 = 100 × 1024 × 1024 × 1024 ÷ (4 × 1024)
               = 100 × 1024 × 1024 ÷ 4
               = 26,214,400 个物理块

(2) 计算位示图大小
    位示图大小 = 26,214,400 bit
               = 26,214,400 ÷ 8 字节
               = 3,276,800 字节
               = 3,276,800 ÷ 1024 ÷ 1024 MB
               = 3.125 MB

答案：
(1) 26,214,400个物理块
(2) 3.125MB
```

**题型2：计算物理块在位示图中的位置**

```
📝 例题3：
某磁盘用位示图管理，每字节表示8个物理块。
第100号物理块在位示图的哪个字节的哪一位？

解答步骤：
1. 字节号 = 100 ÷ 8 = 12（第12个字节）
2. 位号 = 100 % 8 = 4（该字节的第4位）

答案：第12个字节的第4位
```

**🎯 记忆口诀**：
```
位示图大小 = 物理块数 ÷ 8（字节）
字节号 = 物理块号 ÷ 8
位号 = 物理块号 % 8
```

---

#### 3.2.6 文件共享：硬链接 vs 软链接 ⭐⭐

```
文件共享方式
    │
    ├─ 软链接（符号链接，Symbolic Link）
    │   ├─ 类似：Windows快捷方式
    │   ├─ 本质：存储目标文件路径的文本文件
    │   ├─ 存储内容：目标文件的路径字符串
    │   ├─ 删除链接：不影响原文件
    │   ├─ 删除原文件：链接失效，打不开
    │   ├─ 文件大小：很小（只存路径）
    │   ├─ 跨文件系统：可以
    │   ├─ 目录链接：可以
    │   └─ inode号：不同的inode
    │
    └─ 硬链接（Hard Link）
        ├─ 类似：完整复制但保持同步
        ├─ 本质：多个文件名指向同一数据块
        ├─ 存储内容：与原文件共享同一数据块
        ├─ 删除一个：不影响其他硬链接
        ├─ 删除原文件：其他硬链接仍然可用
        ├─ 文件大小：与原文件显示相同大小
        ├─ 跨文件系统：不可以
        ├─ 目录链接：通常不能
        └─ inode号：相同的inode
```

**详细对比表**：

| 对比项 | 软链接（符号链接） | 硬链接 |
|-------|------------------|--------|
| **Windows类比** | 快捷方式 | 镜像文件（占用极小空间） |
| **存储内容** | 目标文件的路径字符串 | 与原文件共享同一数据块 |
| **删除链接** | 不影响原文件 | 不影响原文件 |
| **删除原文件** | 链接失效，打不开 | 其他硬链接仍然可用 |
| **文件大小** | 很小（只存路径） | 与原文件显示相同大小 |
| **跨文件系统** | 可以 | 不可以 |
| **目录** | 可以链接目录 | 通常不能链接目录 |
| **inode** | 不同的inode | 相同的inode |

**🌰 生活化例子**：

```
软链接 = 地址本
    └─ 记录了朋友家的地址
    └─ 朋友搬家了，地址本就过时了

硬链接 = 双胞胎
    └─ 两个人共享同一套基因
    └─ 一个人"消失"了，另一个还在
```

**Linux命令**：
```bash
# 创建软链接
ln -s /path/to/original /path/to/link

# 创建硬链接
ln /path/to/original /path/to/link
```

---

#### 3.2.7 文件访问控制 ⭐⭐

##### （1）访问控制方式

```
访问控制方式
    │
    ├─ 存取控制矩阵（Access Control Matrix）
    │   ├─ 结构：二维表格
    │   ├─ 行：用户1、用户2、用户3
    │   ├─ 列：文件A、文件B、文件C
    │   └─ 交叉点：权限（rwx）
    │
    ├─ 存取控制表 ACL ⭐（Access Control List）
    │   ├─ 中心：以**文件**为主角
    │   ├─ 内容：列出所有能访问该文件的用户及其权限
    │   └─ 使用：Linux/Unix系统使用
    │
    └─ 用户权限表（Capability List）
        ├─ 中心：以**用户**为主角
        └─ 内容：列出该用户能访问的所有文件及其权限
```

**简单记忆**：
```
存取控制表（ACL）= 以**文件**为主角
    └─ 这个文件，谁能访问？

用户权限表 = 以**用户**为主角
    └─ 这个用户，能访问哪些文件？
```

---

##### （2）Linux文件权限 ⭐⭐（实用知识）

**命令示例**：
```bash
$ ls -l
-rwxr-xr--  1  user  group  1024  Jan 01 12:00  example.txt
```

**权限位解读**：

```
文件类型和权限：-rwxr-xr--
│
├─ 位置0：文件类型
│   ├─ - = 普通文件
│   ├─ d = 目录
│   └─ l = 符号链接
│
├─ 位置1-3：所有者权限（owner）
│   └─ rwx = 读+写+执行
│
├─ 位置4-6：所属组权限（group）
│   └─ r-x = 读+执行（无写权限）
│
└─ 位置7-9：其他用户权限（others）
    └─ r-- = 只读
```

**权限符号表**：

| 符号 | 英文 | 数字 | 含义 | 说明 |
|------|------|------|------|------|
| **r** | read | **4** | 读 | 可以查看文件内容 |
| **w** | write | **2** | 写 | 可以修改文件内容 |
| **x** | execute | **1** | 执行 | 可以运行该文件（程序） |
| **-** | none | **0** | 无 | 没有该权限 |

**权限组合计算**：

```
权限组合
    │
    ├─ rwx = 4+2+1 = 7（所有权限）
    ├─ rw- = 4+2+0 = 6（读写）
    ├─ r-x = 4+0+1 = 5（读执行）
    ├─ r-- = 4+0+0 = 4（只读）
    ├─ -wx = 0+2+1 = 3（写执行）
    ├─ -w- = 0+2+0 = 2（只写）
    ├─ --x = 0+0+1 = 1（只执行）
    └─ --- = 0+0+0 = 0（无权限）
```

**🌰 实例**：
```bash
# 设置权限为 755
chmod 755 script.sh

解读：
7 (rwx) = 所有者：读+写+执行
5 (r-x) = 所属组：读+执行
5 (r-x) = 其他人：读+执行

# 设置权限为 644（最常见的文件权限）
chmod 644 file.txt

解读：
6 (rw-) = 所有者：读+写
4 (r--) = 所属组：只读
4 (r--) = 其他人：只读
```

---

## 第四部分：中间件 ⭐

### 4.1 什么是中间件？

```
软件层次结构
    │
    ├─ 应用软件层
    │   └─ 业务系统、APP、网站
    │
    ↓
    ├─ 中间件层 ⭐
    │   ├─ 核心作用1：解耦应用和系统
    │   ├─ 核心作用2：提供通用服务
    │   ├─ 核心作用3：实现跨平台
    │   └─ 核心作用4：屏蔽底层差异
    │
    ↓
    ├─ 操作系统层
    │   └─ Windows、Linux、macOS
    │
    ↓
    └─ 硬件层
        └─ CPU、内存、硬盘
```

**🌰 生活化例子**：
```
中间件 = 翻译官
    └─ 让说不同语言的人能交流

中间件 = 转换插头
    └─ 让不同国家的电器能用
```

---

### 4.2 中间件分类 ⭐

```
中间件8大类型
    │
    ├─ 1. 通信处理中间件（消息中间件）
    │   ├─ 功能：系统间异步通信
    │   ├─ 场景：微服务、消息队列、分布式系统
    │   └─ 产品：RabbitMQ、Kafka、ActiveMQ
    │
    ├─ 2. 事务处理中间件（交易中间件）
    │   ├─ 功能：事务处理和调度、负载均衡
    │   ├─ 场景：银行、证券交易系统（OLTP）
    │   └─ 产品：Tuxedo
    │
    ├─ 3. 数据存取管理中间件（数据库中间件）
    │   ├─ 功能：数据访问、格式转换、在线解压
    │   ├─ 场景：网盘、云存储、分库分表
    │   └─ 产品：MyCAT、ShardingSphere
    │
    ├─ 4. Web服务器中间件
    │   ├─ 功能：浏览器图形界面、会话管理、HTTP处理
    │   ├─ 场景：Web应用服务器
    │   └─ 产品：Tomcat、Nginx、IIS、Apache
    │
    ├─ 5. 安全中间件
    │   ├─ 功能：加密、摘要、认证、授权
    │   ├─ 场景：安全防护、CA认证
    │   └─ 产品：OpenSSL、CA认证系统
    │
    ├─ 6. 跨平台和架构中间件
    │   ├─ 功能：分布式系统管理、节点集成
    │   ├─ 场景：集群系统、多平台整合
    │   └─ 产品：CORBA、DCOM
    │
    ├─ 7. 专用平台中间件
    │   ├─ 功能：特定领域的中间件
    │   └─ 场景：各行业应用
    │
    └─ 8. 网络中间件
        ├─ 功能：网络管理、测试、接入
        ├─ 场景：网络运维
        └─ 产品：SNMP工具
```

**详细分类表**：

| 序号 | 中间件类型 | 别名 | 主要功能 | 应用场景 | 典型产品 |
|------|-----------|------|---------|---------|---------|
| 1 | 通信处理中间件 | 消息中间件 | 系统间异步通信 | 微服务、消息队列 | RabbitMQ、Kafka |
| 2 | 事务处理中间件 | 交易中间件 | 事务处理、负载均衡 | 银行交易系统 | Tuxedo |
| 3 | 数据存取管理中间件 | 数据库中间件 | 数据访问、格式转换 | 分库分表、云存储 | MyCAT |
| 4 | Web服务器中间件 | - | HTTP处理、会话管理 | Web应用 | Tomcat、Nginx |
| 5 | 安全中间件 | - | 加密、认证、授权 | 安全防护 | OpenSSL |
| 6 | 跨平台中间件 | - | 分布式系统管理 | 集群系统 | CORBA |
| 7 | 专用平台中间件 | - | 特定领域服务 | 行业应用 | - |
| 8 | 网络中间件 | - | 网络管理、测试 | 网络运维 | SNMP |

**🎯 记忆技巧**：名字就是功能！
```
消息中间件 → 传递消息
事务中间件 → 处理事务
数据存取中间件 → 数据存取
Web服务器中间件 → Web服务
```

---

## 第五部分：软件构建（组件） ⭐⭐

### 5.1 什么是构建（Component）？

```
构建（Component）= 组件 = 可复用的程序集合
    │
    ├─ 核心特性1：自包容
    │   └─ 功能完整，可独立工作
    │
    └─ 核心特性2：可复用
        └─ 可以在多个系统中重复使用
```

**软件开发演进史**：

```
软件开发演进史（力度越来越粗）
    │
    ├─ 第1代：面向过程（结构化开发）
    │   ├─ 基本单位：模块
    │   └─ 特点：从零开始编码
    │
    ↓
    ├─ 第2代：面向对象（OOP）
    │   ├─ 基本单位：类/对象
    │   └─ 特点：封装、继承、多态
    │
    ↓
    ├─ 第3代：基于构建开发 ⭐
    │   ├─ 基本单位：构建（组件）
    │   └─ 特点：组装式开发（搭积木）
    │
    ↓
    └─ 第4代：面向服务（SOA/微服务）
        ├─ 基本单位：服务
        └─ 特点：分布式、松耦合
```

**🌰 生活化例子**：
```
传统开发 = 手工打造
    └─ 从零开始做一把椅子

基于构建开发 = 搭积木
    └─ 用现成的积木块组装
```

---

### 5.2 基于构建的开发流程

```
基于构建的开发流程
    │
    ├─ 步骤1：需求分析
    │   └─ 理解用户需求
    │
    ↓
    ├─ 步骤2：设计构建
    │   └─ 识别需要哪些构建
    │
    ↓
    ├─ 步骤3：建立构建库
    │   ├─ 收集现有构建（优先复用）
    │   └─ 开发新构建（不足部分）
    │
    ↓
    ├─ 步骤4：组装构建 ⭐（核心！）
    │   └─ 通过接口将构建组装成系统
    │
    ↓
    ├─ 步骤5：系统测试
    │   └─ 确保系统功能完整
    │
    ↓
    └─ 步骤6：系统发布
```

**关键理念**：
```
核心不是"开发"，而是"组装"
    ↓
优先使用已有构建，不足再开发
    ↓
目标：让非专业人员也能开发软件
```

---

### 5.3 商用构建标准 ⭐⭐

#### 5.3.1 三大主流标准

```
商用构建标准（三大阵营）
    │
    ├─ 1. CORBA（OMG组织）
    │   ├─ 全称：公共对象请求代理
    │   ├─ 特点：跨语言、跨平台
    │   └─ 架构：三层架构
    │
    ├─ 2. J2EE（Sun/Oracle）
    │   ├─ 全称：Java企业版
    │   ├─ 特点：Java技术栈
    │   └─ 核心：Servlet + EJB
    │
    └─ 3. DNA（Microsoft）
        ├─ 全称：微软.NET
        ├─ 特点：Windows平台
        └─ 核心：COM/DCOM/COM+
```

---

#### 5.3.2 CORBA三层架构 ⭐⭐（重点！）

```
CORBA三层架构（从下到上）
    │
    ├─ 第1层（基础层）：对象请求代理（ORB）⭐
    │   ├─ 作用：分布式对象间通信的"软总线"
    │   ├─ 功能1：定义对象如何通信
    │   └─ 功能2：定义语言映射
    │
    ↓
    ├─ 第2层（中间层）：公共对象服务
    │   ├─ 作用：提供基础服务
    │   └─ 包括：
    │       ├─ 并发服务
    │       ├─ 命名服务
    │       ├─ 事务服务
    │       └─ 持久化服务
    │
    ↓
    └─ 第3层（顶层）：公共设施
        ├─ 作用：定义构建框架和开发规范
        └─ 包括：构建开发、部署、管理规范
```

**层次对照表**：

| 层次 | 名称 | 作用 | 比喻 |
|------|------|------|------|
| **第1层（基础）** | 对象请求代理（ORB） | 分布式对象通信的"软总线" | 高速公路 |
| **第2层（中间）** | 公共对象服务 | 提供并发、命名、事务等基础服务 | 服务区 |
| **第3层（顶层）** | 公共设施 | 定义构建框架和开发规范 | 交通规则 |

---

**CORBA CCM构建模型**：

```
CCM = CORBA Component Model
    │
    ├─ 规范1：抽象构建模型
    │   └─ 定义构建的结构（构建应该长什么样）
    │
    ├─ 规范2：构建容器结构
    │   └─ 封装构建，实现跨平台运行（容器如何工作）
    │
    └─ 规范3：配置和打包规范
        └─ 定义构建的部署方式（如何打包和部署）
```

---

#### 5.3.3 J2EE技术栈

```
J2EE架构
    │
    ├─ 客户端（浏览器）
    │   ↓ HTTP请求
    ├─ Servlet层
    │   ├─ 作用：接收HTTP请求
    │   └─ 调用：业务逻辑（EJB）
    │   ↓
    ├─ EJB层（业务逻辑）
    │   ├─ Session Bean（会话Bean，处理业务逻辑）
    │   ├─ Entity Bean（实体Bean，映射数据库表，已过时）
    │   └─ Message-Driven Bean（消息驱动Bean，异步消息）
    │   ↓
    └─ 数据库层
        └─ MySQL、Oracle
```

**核心技术表**：

| 技术 | 全称 | 作用 |
|------|------|------|
| **Servlet** | Java Servlet | 接收HTTP请求，调用业务逻辑 |
| **JSP** | JavaServer Pages | 动态网页生成 |
| **EJB** | Enterprise JavaBean | 封装业务逻辑的企业级组件 |
| **RMI** | Remote Method Invocation | Java远程方法调用 |
| **IIOP** | Internet Inter-ORB Protocol | 对象请求代理协议 |

---

#### 5.3.4 DNA（微软.NET）

```
DNA（微软.NET）
    │
    ├─ 核心技术：COM/DCOM/COM+
    │   ├─ COM：组件对象模型
    │   ├─ DCOM：分布式COM
    │   └─ COM+：COM的增强版
    │
    ├─ 主要平台：Windows
    │
    └─ 技术栈：C#、.NET Framework
```

---

## 📊 本章知识体系总结

### 核心考点回顾（线性表）

```
考试重点知识清单（按重要性排序）
    │
    ├─ 1. 系统总线三类型 ⭐⭐⭐（必考）
    │   └─ 控制总线、地址总线、数据总线
    │
    ├─ 2. CISC vs RISC ⭐⭐⭐（必考）
    │   └─ 微程序控制 vs 硬布线逻辑
    │
    ├─ 3. 位示图计算 ⭐⭐⭐（必考计算题）
    │   ├─ 位示图大小 = 物理块数 ÷ 8
    │   ├─ 字节号 = 物理块号 ÷ 8
    │   └─ 位号 = 物理块号 % 8
    │
    ├─ 4. 文件物理结构 ⭐⭐⭐（必考）
    │   └─ 顺序、链接、索引、多级索引
    │
    ├─ 5. 硬链接 vs 软链接 ⭐⭐
    │   └─ inode相同 vs 不同
    │
    ├─ 6. Linux文件权限 ⭐⭐
    │   └─ rwx = 421，chmod 755
    │
    ├─ 7. 存储器四层结构 ⭐⭐
    │   └─ L1→L2→主存→外存
    │
    ├─ 8. CORBA三层架构 ⭐⭐
    │   └─ ORB + 公共服务 + 公共设施
    │
    ├─ 9. 冯诺依曼五大部件 ⭐
    │   └─ 控运存输输
    │
    └─ 10. 中间件分类 ⭐
        └─ 8大类型，顾名思义
```

---

### 学习建议（线性流程）

```
学习步骤（推荐流程）
    │
    ├─ 第1遍：通读全文（理解概念）
    │   └─ 时间：2小时
    │
    ↓
    ├─ 第2遍：重点学习（⭐⭐⭐标注内容）
    │   ├─ 系统总线三类型
    │   ├─ CISC vs RISC
    │   ├─ 位示图计算
    │   └─ 文件物理结构
    │   └─ 时间：3-4小时
    │
    ↓
    ├─ 第3遍：做题巩固（自测题）
    │   └─ 时间：1小时
    │
    ↓
    ├─ 第4遍：查漏补缺
    │   └─ 时间：1-2小时
    │
    ↓
    └─ 考前复习：只看"核心考点回顾"
        └─ 时间：30分钟
```

---

## ✅ 自测题

### 一、选择题（每题2分）

**1. 以下关于CISC和RISC的说法，正确的是？**
- A. CISC采用硬布线逻辑，RISC采用微程序控制
- B. CISC指令数量少，RISC指令数量多
- C. CISC采用微程序控制，RISC采用硬布线逻辑 ✓
- D. CISC和RISC的指令长度都是固定的

**2. 32位地址总线最多可以寻址的内存空间是？**
- A. 2GB
- B. 4GB ✓
- C. 8GB
- D. 16GB

**3. 系统总线不包括以下哪一种？**
- A. 控制总线
- B. 地址总线
- C. 数据总线
- D. 电源总线 ✓

**4. 在Linux系统中，文件权限 rwxr-xr-- 对应的数字表示是？**
- A. 755
- B. 754 ✓
- C. 644
- D. 744

**5. 以下哪种文件物理结构支持快速随机访问？**
- A. 顺序结构 ✓
- B. 链接结构
- C. 索引结构 ✓
- D. 以上都不对

**6. 某磁盘有20,480个物理块，采用位示图管理空闲空间，位示图需要占用多少字节？**
- A. 1,024字节
- B. 2,048字节
- C. 2,560字节 ✓
- D. 4,096字节

**7. CORBA三层架构中，最底层是？**
- A. 公共设施
- B. 公共对象服务
- C. 对象请求代理（ORB） ✓
- D. 构建框架

**8. 以下哪个不属于中间件？**
- A. 消息中间件
- B. 事务中间件
- C. 数据库管理系统 ✓
- D. Web服务器中间件

---

### 二、简答题

**1. 请简述硬链接和软链接的区别。（10分）**

<details>
<summary>点击查看答案</summary>

**软链接（符号链接）**：
- 类似Windows的快捷方式
- 存储的是目标文件的路径字符串
- 删除软链接不影响原文件
- 删除原文件会导致软链接失效
- 可以跨文件系统
- 拥有不同的inode号

**硬链接**：
- 多个文件名指向同一数据块
- 与原文件共享相同的inode号
- 删除一个硬链接不影响其他
- 必须删除所有硬链接才能释放磁盘空间
- 不能跨文件系统
- 通常不能链接目录
</details>

---

**2. 某磁盘容量为100GB，物理块大小为4KB，采用位示图管理空闲空间，计算：**
   **(1) 磁盘总共有多少个物理块？**
   **(2) 位示图需要占用多少MB的存储空间？**

<details>
<summary>点击查看答案</summary>

**(1) 计算物理块总数**：
```
100GB = 100 × 1024 × 1024 × 1024 字节
4KB = 4 × 1024 字节

物理块总数 = 100 × 1024 × 1024 × 1024 ÷ (4 × 1024)
           = 100 × 1024 × 1024 ÷ 4
           = 26,214,400 个物理块
```

**(2) 计算位示图大小**：
```
位示图大小 = 26,214,400 bit
           = 26,214,400 ÷ 8 字节
           = 3,276,800 字节
           = 3,276,800 ÷ 1024 ÷ 1024 MB
           = 3.125 MB
```

**答案**：
- (1) 26,214,400个物理块
- (2) 3.125MB
</details>

---

## 📚 扩展阅读

### 推荐书籍
```
基础书籍
    ├─ 《计算机组成原理》（唐朔飞）
    ├─ 《操作系统概念》（恐龙书）
    └─ 《UNIX环境高级编程》（APUE）

进阶书籍
    ├─ 《深入理解计算机系统》（CSAPP）
    └─ 《现代操作系统》（Tanenbaum）
```

### 在线资源
- Linux文件系统：https://www.kernel.org/
- CORBA官方文档：https://www.omg.org/
- Java EE教程：https://docs.oracle.com/javaee/

---

## 📝 总结

### 本章五大模块

```
第一章总结（分值预测：6-9分）
    │
    ├─ 硬件基础（⭐）
    │   ├─ 冯诺依曼五大部件
    │   ├─ CISC vs RISC ⭐⭐⭐
    │   ├─ 存储器四层结构
    │   └─ 总线三大类型 ⭐⭐⭐
    │   └─ 预计分值：1-2分
    │
    ├─ 软件基础（⭐）
    │   ├─ 系统软件 vs 应用软件
    │   └─ 预计分值：1分
    │
    ├─ 文件系统（⭐⭐⭐）重点！
    │   ├─ 逻辑结构：记录式 vs 流式
    │   ├─ 物理结构：顺序/链接/索引 ⭐⭐⭐
    │   ├─ 空闲空间管理：位示图计算 ⭐⭐⭐
    │   ├─ 文件共享：硬链接 vs 软链接 ⭐⭐
    │   └─ 访问控制：Linux权限 ⭐⭐
    │   └─ 预计分值：3-4分
    │
    ├─ 中间件（⭐）
    │   ├─ 8大类型
    │   └─ 预计分值：1分
    │
    └─ 软件构建（⭐⭐）
        ├─ 基于构建的开发
        ├─ CORBA三层架构 ⭐⭐
        ├─ J2EE技术栈
        └─ DNA标准
        └─ 预计分值：1-2分
```

**下一章预告**：操作系统（⭐⭐⭐ 核心考点，10-15分）

---

> **📅 文档信息**
> 版本：线性图解版 v1.0
> 生成时间：2026-02-02
> 适用考试：软考高级系统架构师
> 编写风格：线性结构、层次清晰、易于理解
