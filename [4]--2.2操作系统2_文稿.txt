	好，然后接下来的话，我们再来看一下进程管理面的死锁的问题。死锁的问题其实我们在前面在讲那个进程志愿图的时候就跟大家提到过，是不是思索考的也比较多，也比较多，你要注意，前面你就看到了我们讲的那个进程处于阻塞，就是阻塞进程它就是一个什么？就是一个死锁的，就说一个进程在等待永远不可能发生的事件。刚才你看到了那个PR对不对？他想要申请那个资源，但这个资源是零个，没有资源你想去申请，他申请不到，不可能发生对吧？那么这个时候的话，这个进程就会是时速。如果说系统里面多个进程是时速，那么系统就有可能时速，对吧？刚才我们也看了整个系统会不会死锁，怎么化解，对不对？
	那这个时候我们来看一下，这里有我们系统死锁产生的四个必要条件。这个要记一下，四个必要条件。第一个叫资源互斥，就是说进程申请的资源是互斥的，因为共享的话就不存在。然后第二个的话，就是每个进程都占有资源，并且等待其他资源，这个叫请求和保持，知道吧？换句话叫请求和保持，就是说我们进城我们自己拥有的资源我是不会释放掉的。我占有了我就算不运行，我也不会把它释放掉。然后我还在等待别的资源。
	然后第三个的话叫系统不能剥夺进程资源。系统不能剥夺，就是你系统不能强制的去剥夺。比如说你直接把任务管理器出来，把这个进程给care掉，你不能这样，这样是作弊，对不对？第四个的话是叫进程资源图，是一个环路。我们前面不是讲过进程资源图资源图这个环路很好理解，是它它在等它，形成了一个环，你在等我，我在等你，对吧？大家谁都不释放，谁都不让谁形成一个环路，这就整个系统就失去了。
	好吧，死锁的四个必要条件要记。然后接下来就是死锁产生之后，我们知道系统线路死锁，我们肯定是要解决死锁的。那么解决死锁的措施就是什么呢？打破四大条件，就是打破市场条件，打破其中一个就可以了。
	那么我们分为什么呢？叫事前和事后的方式，事前的方式就称为叫死锁预防。死锁避免就是说我们在思索发生之前，我们就想办法不让思索发生。你看吃着预防，我们可以采用某种策略去限制并发进程对于资源的请求。此所避免的话就是采用银行家算法。这个算法后面我们会通过题目去讲一下，它跟进程资源图的方式很类似，只不过进程锥形图是图形的方式，这个是一种表格的方式，这个算法也很贴切，它什么意思呢？就是说它会提前计算出一条不会死锁的资源分配方法，就跟那个资源分配图的他那个化简一样。他确定这样是可行的，他才会分配给你，不可行的就不会给你好吧。
	然后还有的话后就是我们死锁产生之后，就是我们允许死锁的产生。但是我们产生之后，我们把它给什么给消除掉？怎么消除呢？首先就是你要先能检测到死锁，一旦发有有我们死锁的程序，比如说阻塞进程，你要能检测得到这个进程发生了阻塞，然后立马你就把这个进程给他什么给他解除掉。你不要让阻塞进程太多了，导致整个系统阻塞了，那那你就完蛋了，是不是？
	解除这个进程的阻塞也很简单，就是破坏条件。就直接我刚才讲的直接kill掉这个进程，对吧？直接把这个阻塞的进程给它杀掉。我相信大家应该遇到过这种情况，对不对？有时候跑着跑着这个软件就死了，死机了，突然不动了，突然不动了，就是白了，那个鼠标就在那里画圆圈了。这个时候就是怎么样直接把任务管理器调出来，把这个进程给他杀掉是不是？然后再重开就行了，就这种方式好吧？好，这是要注意。
	然后接下来我们再来看下面这个点也很重要，叫死锁资源的计算。这个思索资源什么意思？就是一种很简单的计算题。就是说假设我们系统里面有N个进程，每个进程都需要哪个资源才能运行？就你每个进程都需要R个资源才能运行，那么我们这个系统里面发生死锁的最大资源数是多少？发生事故的最大资源数就是什么呢？
	就是我给每个进程R减一个资源，你想一想是不是这个道理，对吧？你每个进程都需要一个资源，那我就给你每个进程正好少一个资源。给你每个进程都少一个资源，那你所有进程都运行不了，所有进程就都死锁。这是我们发生死锁的最大资源数。因为你的资源数如果说比这个更小，就更容易发生死锁，对吧？
	好，然后还有第二个就是要不发生死锁的最小资源数。如果说你想让这个系统不发生死锁，那怎么样你就只需要再给他加一个资源就可以了。因为你给他再加一个资源，那么必然有一个进程是可以满足R的资源的，必然有一个进程可以满足R个资源。这个进程有了R个资源它就运行了。它运行完之后，他会把它拥有的R个资源都怎么样都释放掉，那大家都可以跑了，对不对？
	所以这两个计算，好，然后接下来我们再来看一下这里我们讲的进程和线程的区别，这个也经常考好吧？正常来说我们讲的传统的我们讲的进程进程的话，它有两个特性。第一个的话叫可拥有资源的独立单位。第二个是可以独立调度和分配的基本单位。这个你要注意，可以拥有资源的独立单位是什么意思，就是我们这个进程是能够去独立分配资源的。独立调度的话就是它可以被独立的调度和分配。
	那么我们当我们引入了线程之后，我们知道一般我们一个进程里面可以创建多个线程，线程是比进程更小的单位。那么县城就变成了什么呢？独立调度的基本单位。大家注意，但是进程还是拥有资源的基本单位，这是他们俩的第一个区别，就是县城变成了独立调度的单位了。
	好，那么第二个区别在于什么呢？就是我们知道县城它不是资源的单位，资源的单位还是县城，就意味着什么？意味着县城本身是不拥有资源的，要注意，县城本身是不拥有资源的，资源还是在县城里面。当我们在一个进程里面创建了多个县城的时候，这些县城是共享这个进程的资源的。看到没？县城本身不拥有资源，它与同属一个进程的其他县城共享这个进程的全部资源。这些资源一般就是我们的公共数据、全局变量、代码、文件数据这些。但是的话你要说县城真的没有资源也不是的。县城它还是有自己运行中必不可少的资源，就是对自己这个线程的标识。比如说程序计数器，它自己的一些寄存器，还有站以及它的线程控制块TCB这些，包括栈指针好吧，他自己的一些站吸尘器这些，这个要注意，这是第二个区别，就是资源的问题好吧，这是考点。
	好，然后接下来。
	我们再来看一下这里的一个叫中断的概念。好吧。就是在我们操作系统的运行过程当中，我们经常会产生中断对不对？中断的话是什么意思？就是说某些事件发生终止了我们当前进进程的运行，就是有事情发生。比如说我刚才讲的一个高优先级的进程来了，而且它是一个可剥夺的。那么这个高优先级的一来，它就会产生一个中断，让你当前这个低优先级的进程暂停运行，然后剥夺你的CPU他自己去运行，对吧？这本质上它是属于一种事件驱动的架构，对不对？
	好，那么中断的话，我们了解一些基本概念，比如说中断源是引起中断的事件，出发源中断处理程序就是什么呢？对出现的中断事件进行处理的程序，还有中断的响应，对不对？就是说你暂停当前的运行，你让操作系统的中断处理程序去响应的过程。
	好吧，一般中断的处理的话，有的时候比较简单的流程就是什么呢？就比如说中断，你要看你是允许嵌套的还是不允许嵌套的。如果你是不允许嵌套的中断，那你首先来了一个中断源之后，你要先什么？当你转到中断处理程序，你要关中断的是吧？关中断的。所以中断响应，找到入口地址，中断处理程序，然后中断结束。当然你中间还要保存我们的堆和站，对不对，这些东西。然后还有下面就是我们中断的一个分类，这个分类这个分类大家注意一下。
	我们的中断可以分为叫程序性中断。就顾名思义去理解，就是你当前发生的程序性质的错误，出现了某些特定的状态产生的中断。比如说你看最经典的内存越界跟踪，就是因为你的什么？因为你自己的程序代码有问题产生的中断。这个在大家编程的时候最不愿意看到的就是叫什么call dump断错误，对吧？我们在写代码的时候，其实最怕的就是这个东西了断错误。因为断错误扩大会直接导致我们的程序什么崩溃掉，是不是？
	然后第二个是我们的外中断，外中断就是什么？就是外部的，你看到由外部的非通道式装置所引起的中断。比如说你看这里的时钟中断，操作员控制台中断，那就是外部我直接强制的把它杀掉。比如说你程序中你可以理解为是主动的这种崩溃，程序自己崩溃了，这个可能是外部的，我就想把这个进程给他直接kill掉。杀掉好吧，外部的中断。
	然后第三个叫数输出，就是我们讲的IO那么它就是外设，对吧？就是我们的IO你看到他说的是正常结束发生错误时发生的中断，这个一般指的就是外部设备。比如说打印机缺纸、缺墨，是吧？读磁盘的时候没有数据，对不对，这是外部设备相关的。
	第四个的话叫硬件故障中断，就是机器发生故障，机器发生故障。这个你要注意，这个硬件故障中断跟输入输出中断有一点类似。因为输入输出中断我们讲的也是我们的外部的硬件设备，对吧？但是的话它这里的话会偏向于是因为故障导致的。比如说电源故障没电了，内存故障，因为故障，因为问题导致的，而上面它不能叫故障。你看打印机缺纸，这个不能说是打印机的故障，它就是缺纸缺墨懂吗？不能说是它的故障，所以两个要区分开来比较相近。
	然后第五个叫房管中断，房管的话就是什么呢？就是我们对操作系统提出某种请求时发生的中断，这个一般就是我们在进行系统调用的时候会发生中断是吧？系统调用就比如说我们的用户当前在使用这个操作系统，我们在用户态我们想调用一个系统的调用程序，那这个时候你就要切换到系统态去调用这个系统调用好吧，你看这里的IO传输，打开文件这些好吧，说实话它是完成系统调用的。
	在这里面我们刚才提到就是什么叫用户态，什么叫内核态，这个你要知道对吧？这是基本的，这个不会考。但本的概念稍微跟你讲一下，用户态就什么？就是我们当前我们是处于用户的这个运行的状态。内核的状态就是你要进行一些系统的调用，操作系统的调用的时候，所以你从用户态切换到内核态进行系统的调用，就会进行房管中断好吧。
	还有比如说单体内核微内核的概念，这个很好理解，就是内核里面的内容如果比较少，比较微小就是微内核，比较微小就是微内核。如果内核比较多就是什么呢？这里面内容比较多，就是单体内核好吧？这两个的这个优选缺点，这个后面我们还会去讲解，因为有有相关的这个概念好吧，这个先了解一下。
	好，然后接下来的话就是我们这个进程管理这一块的一些习题。概念题比较简单。首先我们看一下这一题应该选什么，刚才大家有看吗？进程中运行态变成就绪状态的条件是什么？运行到就绪，我们讲的这个三态图自己心里要能画出来。
	运行到就绪是什么？就是我们的时间片被时间片到了，简单来说就是什么呢？就是CPU没有了，对吧？CPU没有了，那我们看这里主动让出CPU这是对的。
	信号量执行wait方法，这个不这个wait就类似于那个P对不对？然后的话就是确认中断，中断是不会变成就绪的，中断直接变成什么阻塞了是吧？阻塞包括请求磁盘也是的，直接变成阻塞。好，然后再往下这个题目，以下什么不属于操作系统死锁预防的方法。
	操作系统死锁预防的方法，这个大家可以好好看一看。我们刚才跟大家讲应该选什么？我们讲你要避免死锁，你就什么破坏它的适当条件，破坏它四大条件，OK破坏四大条件。那么我们发现好像这就是它的四大条件，看到没？请求和保持互斥、不可抢占、循环等待，这好像就是它的四大条件了。这个请求和保持就是占有资源并等待其他资源。互斥就是那个不可抢占的话，就是指你系统不能强制的去剥夺。循环等待就是那个进程资源图是个环路，对吧？
	这ABCD正好就是四大条件，它这里正好就是破坏了四大条件。那按理来说什么？按理来说这四个好像都是对的那因为我们讲的是破坏四大条件，那么很明显这四个条件里面有一个条件，什么是不能被破坏的，或者说破坏这个条件是没有用的。哪一个条件呢？这个需要大家思考一下，哪一个条件互斥？
	互斥为什么？因为互斥这个条件你是没有办法去破坏的，这个是他资源本身的固有属性，资源本身的固有属性它就是互斥资源。你不能说我把它变成共享的，你不但不能破坏，你还要保持知道吗？但是别的都可以破坏。比如说我资源占有了，我可以主动把它释放掉，这个我系统可以强制kill掉，对吧？所以的话这里选B这个大家要注意。
	然后就是下面这个题目，这个题目比较有意思。这个题目一般来说你可能来不及做了，你可以看一下。当然你可以自己到时候去做一下，画一下。
	我来直接跟大家讲，你可能已知某单CPU操作系统，这里的单CPU就指单核的意思，好吧。两个任务P1和P2这两个进程，两个进程一个核。其中任务P1执行任务P1你看到依次执行40毫秒计算，60毫秒IO40毫秒计算，任务P2依次执行100毫秒计算，40毫秒IO40毫秒计算。已知任务P2晚启动，20毫秒就P1先启动。且该操作系统采用非抢占式进程调度策略。非抢占的意思就是你后面优先级高，你不能来抢我的。请问该系统执行完两个任务的总时间是多少？
	这个题目应该是2024年11月份的一个真题，我们整个都是近几年的真题，25年的，这个应该是2024年11月份的一个真题，好吧，这个题目是比较有意思，比较有意思，就是他给的条件很多，它的每个条件都是有作用的。首先它只有一个CPU内核，那么你有两个任务，那么很明显你两个任务不能同时去什么去占用这个CPU。然后还要你还要注意，就是这里它依次执行的任务有两种任务，一种是计算任务，一种是IO任务。那我们知道计算任务是需要什么？是需要占用CPU的。因为CPU完成计算，对吧？而IO是我们的外设，就是外设的输入输出，这个是不需要占用CPU的，因为外设在那里输出就可以了，对吧？
	那么这个时候他执行完两个任务的总时间，我们需要去画一个时空图时空图，这个时空图怎么画呢？很简单，就像这样你看到像这样，然后的话我们认为这是我们的任务一的CPU时间，这是我们的任务二的CPU时间。这个是什么呢？这不是任务一任务2，CPU只有一个，没有任务一、任务2。大家注意就说这个是我们的CPU的，因为我们只有一个CPU这是我们CPU这是我们任务一的IO这是我们任务二的IO像这样，因为你CPU只有一个，所以你这里换一个，它不能并行，但是IO的话不占用CPU，那么IO是可以并行的，IO是可以并行的，然后的话这是我们的时间。
	那我们来看一下，首先我们看到应该是先运行P1，因为P2是晚启动20毫秒，那肯定我先有P1先运行P1了。那P1怎么运行呢？P1先运行40毫秒的计算，计算就是要占用CPU，那么它运行40毫秒，40毫秒对吧？OK然后接下来的话就是什么呢？接下来我们知道在什么，在第20毫秒的时候，我们的PR到来了。因为PR只是晚启动了20毫秒，所以PR其实在这个时候已经到来了，但是没有用。因为我们目前采用的是叫非抢占式调度。非抢占的意思就是说你PR即使你的优先级更高，你也不能抢我的你也不能抢我的，所以P2只能乖乖等待。
	好，那么这个时候接下来我们的P1要运行什么呢？60毫秒的IO所以的话PE紧接着运行60毫秒的IO那这样的话就变成了到这里就100对。那么这个时候我们要注意，就是接下来P1要运行什么40毫秒的计算，就是要再占用40毫秒的CPU。
	那么问题就来了，问题来了，这个时候PR到底在干嘛？我们CPU到底是不是空的？这个时候我们要注意我们的PR它要从什么时候开始占用CPU的。它从40毫秒这时候开始，因为PR在20毫秒的时候已经来了，来了之后等它运行完，等它运行完，CPU空出来，它就立马占用CPU，再用CPU它会运行100毫秒的计算，就是直接到140，它会运行100毫秒的计算，对不对？
	那么这个时候大家注意，到这里他才把这个CPU释放出来。也就是说这个时候我们什么，我们这个PE才能再次占用CPU。就是说P你虽然说在100时候你已经空了，你要执行这个40毫秒的计算的。但是的话你什么但是这个时候CPU不控，你不能去剥夺它。不管你优先级高还是低，你不能去剥夺它。你不空，那这个时候就怎么样，这个时候你就PE你就只能在这个时候再占用CPU。你在占用CPU你要执行多少？你要执行40毫秒的计算任务，所以的话它会再执行40毫秒的计算。到这里180到这里P1就结束了。
	P1是在第180毫秒才结束了，但是P2还没有。P2我们紧接着应该运行什么？应该运行40毫秒的IO就P2你看到在这里140这里结束，紧接着它运行40毫秒IO。IO不需要再用CPU可以并行40毫秒IO好，40毫秒IO运行完了，正好也是在180。接下来它要运行什么？他要运行40毫秒的计算这个时候正好这个时候CPU空出来了，看到没？CPUP1运行完空出来了，在运行40毫秒计算。那这个时候我们的时间是什么？220毫秒，也就是说我们两个任务运行完总时间是220毫秒，对吧？
	你看这个题目稍微复杂一点，这个题目还有很多的变种。比如说它可以规定一个优先级，比如说P1优先级比P2高，并且采用的是抢占式调度，那这个时候又都变了。如果P1比P2高采用的还是抢占式调度，那么在什么时候会被抢，什么时候被抢？在P1在100这里它运行完之后，这里他会抢他的CPU抢了之后就是先运行P1的计算，然后PP2剩下来的那些时间后面再运行。这个后面变种就比较多，你可以自己去尝试一下好吧？好，然后的话我们可以来看一下这个进程资源。
	图的问题。
	这个题刚才给大家看到过对吧？就进程资源图最开始讲的，这个就是判断我们两个考点，一个是阻塞节点，一个是什么呢？可不可以化解？
	那我们来看一下我们说的以什么以我们的资源，你看这个一共是两个资源出去了几个一个两个还剩多少？还剩零个资源进来了几个一个那么你PR想要申请我没有的资源，那么你PR就什么阻塞节点。很简单，我们再看一共有三个资源，OK出去了几个？一个两个三个出去了，三个也没有资源了，进来了几个？进来了一个P1，你P1再申请一个没有的，那么你也是主色节点，对吧？再看R3，R3有2个资源出去了几个出去了一个，还剩一个资源进来了几个，进来了一个他在申请他他正好有一个可以，所以它是非注册节点对吧？这里就是我们讲的就是非准就P3，P3是非主设计的，那么这里是P1P2是阻塞，P3是非阻塞对吧？
	那么这个可不可以化解呢？化简我们刚才讲的从什么？从我们的非阻塞节点开始，因为阻塞节点已经死了，死在那里他动不了了。
	你只有从非组织节点开门，也就说你只能从P3开始入手OKP3入手化简，那么我们就应该什么？我们就应该把P3需要的资源给他，P3需要一个R3，我们就把这一个R3给到他，给到他之后它就可以运行了。它运行完之后，它会把它拥有的资源释放掉。它拥有什么呢？它拥有一个R1，那么现在R一就变成一了，它因为我刚才给他的一个R3，R3又变成一了。那这个时候R1和R3都有一个资源，R1和R3不对，P3还有一个R看到没？
	P3除了有一个R1，有一个R3，刚才分配的R3还有一个R那么R也释放掉了，也有一个资源，那相当于现在P3执行完之后，R1、R2、R3都各有一个资源。那这个时候我们刚才讲的P1P2都是非主射节点的，都可以了。就是说你P3，到P1P2是可以的，到P2P1也是可以的，但是要是P3开头的对吧？注意。
	好，然后我们再来看一个进程的同步和互斥，以及前驱图的题目。这种题目在改版之前是比较经典的。改版之后其实这样这种题目还没有考过，可能是改版之前经常考。但这种题目虽然说改版之后没考过，但是不一定不会考，好吧。而且的话艺考你看就是好几分，所以的话这种题目我们也是需要掌握的，需要掌握好。那么这个题目的话类似的题目我们课后习题有很多，这里我们上课就直接讲，当然大家也有兴趣也可以做一做好吧？
	你看这里这是一个进程资源，这是一个前驱图。大家看出来吧？P1执行完之后才能执行P2P3前驱图。下面是一个伪代码，伪代码他这里在这个伪代码里面，他让你填这个123456，要填这个空，对不对？OK填这个空很简单，我们来填一下，就是你看到要填的就是PV操作，PV操作，刚才我们讲的前驱图，我们讲的几个特点还记得吗？第一个就是这里面的每一根线都代表一个信号量，每一根线一个信号量，然后这个线出去的就是释放这个信号量叫V进来的就是申请这个信号量叫P对不对？
	那么我们来结合这个伪代码，我们来看一下，我们首先看一下进程P1的一个执行的情况。P1你看到P1执行它可以直接执行，它不依赖于任何东西。他执行完之后会有什么效果？它执行完之后会释放两个信号量，就这两个信号量对不对？那么就是两个V那么这两个V要注意哪个是S1，那个是S2，我们是不知道的那我们可以先假设，要大胆假设，小心求证。我们可以假设它是S1，它是S2，那么我们执行的操作就是VS1和VS2，这是一，那么P的就不对了对吧？
	好，那么接下来我们再往下PR，PR在这里OKPR在执行的时候首先要怎么样要申请一个信号量？PR在执行的时候需要申请一个信号量，就是需要P这个信号量。那么这个信号量到底是S1和S2，我们还没有确认，还没有确认，所以这里到底是A还是C还暂时还不确认。因为我们不知道这个信号量到底是S1S2，我们有往下走PR执行。PR执行完之后会释放两个信号量，就这两个了。释放两个情况下S3S4，那么我们也不知道哪个是三哪个是四。那我们先假设，假设它是3，它是4，好吧？先假设没有关系，往后走到这个P3了。
	P3我们看一下P3在执行的过程当中，首先要申请两个信号量，一个是这个，一个是这个。那么他这里申请两个信号量，一个是PSR。PSR就意味什么？就意味着这个是SR，这个是SR对不对？因为刚才S1S2没确定，那现在我们就验证了这是S2，那么这个就是S1。
	刚才第一个题目就是选C了对吧？OK然后接下来除了依赖于这个之外，还依赖于一个什么东西？还要依赖于这一个信号量，那这个信号量到底是三还是四呢？
	这个信号量到底是三还是四？那这个时候你就往下看了，你看他给你的是什么？他给你的都是PS3，因为你肯定是P操作，不可能是微操作，对吧？他给你的都是PS3，没有S4，那就意味着什么？那就意味着这个玩意是S3，而这个玩意是S4。也就是说我们刚才假设错了，对不对？这个没有关系，大胆假设，后面去验证它，小心验证好吧？那么我们这里就确认了这是三，这是4OK。
	那么再往下走P3执行，P3执行完之后又会释放两个信号量，就这两个，这个时候编号应该到了什么五六了，那我们就假设它是5，它是6，还是要假设它是5，它是6，那么释放就是什么？就是VS5和VS6对吧？OK. 
	那么接下来在P4，那你看到P4执行需要什么？需要申请两个信号量，一个是刚才讲的PS4，一个是下面这个。你看到一个是PS4，一个是下面这个PS5，他就告诉你了，所以这个就是五，这个是六，这个我们的假设也是对的，对吧？
	那么批次执行完之后会释放一个信号量，在这里释放的这个信号量编号就是七了。VS7编号就是漆的，这个没有什么疑问的。因为只有一个就是七。你不可能说我七不变，我跳到8，对不对？VS7所以这个答案就出来了，往后你可以有兴趣，你可以自己去推。看到没？
	这样的一个验证的过程，就把握两点就行了。第一点，前驱图里面每一根线都是一个信号量。第二点的话就是什么呢？就是我们这根线出去的是V进来的是P然后去根据这个有的时候给的是伪代码，这个要难一点，有的时候给的是程序流程图，还更简单一点，好吧。好，然后接下来。
	我们再。
	来看一下下面一个叫银行家算法这个题目。这个是我们在什么时候讲到的？是我们在讲操作系统什么死锁预防的时候，还记得吗？应该是死所避免，死所必免。死所避免的时候，我们通过银行家算法，它跟进程资源图的化简是类似的，就是表示形式不一样好吧？就是说我们计算出一个安全的序列，安全我才把这个资源给你，就跟你去贷款一样的，看你的征信，你还得起才贷给你好吧？
	这个我们可以看一下，你看到假设系统里面有三类互斥资源，R1、R2、R3，可用的资源数分别是十五三。在T0时刻系统中有P1到P55个进程，这些进程对资源的最大需求和已分配资源数如下表述。是此时系统剩余的可用资源数是多少？剩余的可用资源数，那我们就把什么就把我们的总资源减掉，已经分配的就可以了，对吧？总资源分别是十五三已经分配了。
	我们看一下RE已经分配了多少个，这是它已经分配的，就把这一列全部都加起来就行了，对不对？R一已经分配了1加23678，RR已经分配了12345，R3已经分配了12。那么减掉之后等于多少？201201对不对？这是我们剩下的资源，P1P2PR1R2R3好。后面就是问你化简了，就说我们的进程按什么序列执行，这个系统状态是安全的，按什么序列执行是安全的这就跟我们前面讲的进程资源图的化简是类似的，就是表格的形式。就是说我把这个资源我先分配给谁，谁能执行完，然后再分配给谁，能够保证我所有的进程都执行完好。
	那这个时候我们想要知道我们当前剩余的资源，这个201应该分配给哪一个进程，我们这个进程才能执行完。那么我们应该怎么样？我们就应该去看我们哪个进程需要这些资源，或者说进程需要的资源正好是201，或者说少于这么多。因为你比这个多，我就没有办法运行了，对不对？那么我们就应该去计算一个什么叫还需或者说尚需资源数，我们就应该再计算一个叫上需资源数，对不对？上需资源数怎么计算？还是一样的，R1、R2、R3怎么计算？就是把最大需求量减掉已分配的那不就是你还需要的，对不对？
	那我们可以减一下，看看五三一减掉之后是420，这个减这个是1110，这个减这个是3301，这个减这个时候是21，这个减这个是101，对吧？OK, 现在我们看一下我们剩的资源是201，那么201能够满足谁呢？你会发现这里的201只能够满足我们的P5，别的都不行，201要3个都满足，201只能够满足P5。你看P2不行，没有，对不对？P4也不行，是不是？所以只能够满足P5，所以他的第一个只能是P5，他只能把资源先给P5，因为给别人运行不了给P5。
	OKP5运行完之后会怎么样？我们讲了会把他拥有的资源都给释放掉，那么等我们把资源给他之后，他拥有的资源就多少，就是这里的最大资源数，或或者说或者说的话，我们现在它释放了多少资源，它就是把它已分配的资源给它释放掉，就之前已分配的，刚才已分配的我们就不算，对不对？就是我们之前是201，把之前他已分配的资源执行完给释放掉，那我们就加上。
	这个110。
	现在我们拥有的资源就是什么？三一一现在我们就有这么多资源对吧？就是一开始有的加上他执行完之前有的已分配的，对不对？311那这时候你再看三一一能够满足谁？三一能够满足谁？能够满足P2P3都可以。三一能够满足P2P3都可以，对不对？所以你接下来要么是P2要么是P3。那么你再看这个答案，P5之后要么是P2要么是P3，那就只有B了对吧？
	因为P1肯定是不对的，所以这个题目你往后做，不用做那么久，你做到第二个答案就出来了。当然如果说到第二个答案还出不来，你还可以继续往后做，把整个流程走完，原理都是一样的原理都是一样的，对不对？就是你满足它，把它运行完，运行完之后，然后把它是已分配的这个资源释放给它加上，然后剩的资源看还能满足下一个，好吧？这个后面你就自己去推一下。
	我就不推了。
	好，然后接下来的话，我们再来看到的是存储管理的。你看进程管理，刚才我们讲的这个内容非常多，它的题型也很多是吧？因为考进程管理考的是最多的，就占了一半好吧？操作系统一半都是考它，所以它的内容本身也占了那么多。接下来我们后续的几个管理的话它的内容加起来可能也就进程管理那么多了。
	首先我们看到是存储，存储我们讲了它主要是对于什么，我们的内存空间进行管理，也就是储存空间知道内存。那么内存空间进行管理，我们有几种不同的管理方式，叫分区存储管理、分页存储管理、分段存储管理以及什么段页式管理。好吧，我们来循序渐进的展开。首先是分区存储，分区存储简单来说就是一种叫整存整取，也就是说我们的进程运行需要内存，我们就把它需要的内存全部都一起分配给他。就你这个程序一共需要多少内存，把这个内存全部都给你，所以这是一种叫整存整取的方式。这种分配方式的话，它又包括3种不同的分区。
	你看有这种固定分区是一种静态分区。就是说我首先把我的这个内存分配，首先把我们内存切割成固定大小的分区。比如说我内存我就切割成十兆，十兆字节是一个分区。那这个时候你来了一个，比如说你来了一个是九兆的那我就把这个空间分配给你，我就给你这个九兆的，给你一个十兆的空间。
	那这个时候大家知道它会产生什么？会产生浪费，这个浪费我们称之为叫内部碎片。因为什么呢？是我们这个分区一块内部的碎片，这个内部碎片是一兆B对不对？内部碎片好，可变分区我们又称为叫动态分区方法，它是一种完全的整存整取。
	就是说你的这个进程在装入到我们内存里面的时候，我再给你划分空间。因为你在装入到内存的时候，我就知道你到底需要多大的内存，我就给你正好那么大的内存。比如说你就是只需要九兆的内存，我就直接从内存里面去切九照给你就正好不多不少。那么这种情况下的话，它不会存在内部碎片，对吧？因为正好的一块正好没有内部碎片，但是的话它容易产生外部碎片，你看各有利弊。
	外部碎片是什么意思？因为它不是在内存里面去切去切，就是说你是九兆，我正好切九照给你。你是5KB我直接切5KB给你，就跟你去菜市场买肉一样的，买一块猪肉，有人说我只要这一块切了，我只要这一块切了，那么可能剩下来就是什么？就是一些边角料，就是我切来切去，可能我最后就剩下一些不连贯的比较小的这些空间，我没有办法分配给任何的进程，导致这些浪费。但是这个浪费是属于外部的，这个快外部的叫外部水平知道。
	所以的话为了解决这种问题，我们又推出了一种叫可重定位分区。它可以解决这种外部碎片的问题。就是因为你切来切去你就可能什么你就可能把那些碎片给它分开了，对吧？你切来切去就可能产生很多不连贯的这种碎片，你单独的碎片不好分配给谁。那这个时候我就想办法把什么把你这些不连贯的碎片给它连起来不就得了，这叫可重定位好吧？就是我们把这些不连贯的这些空闲空间给它全部都连起来，连成一个连续的区域，一个足够大的区域。这样我们又可以分配给别的进程了，好吧？这个叫可重定位分区这三种方式。
	好，然后接下来我们再来看到叫页式存储，分页存储，这是我们最重要的主要的考点，好吧？我们前面讲，我们的分区实际上整存整取。这种整存整取存在一个很大的问题就什么？就是你的内存空间永远是不够的。有的学员可能想我内存大，我64GB内存对吧？不行，我配256GB内存，是不是我要狂加内存条对吧？那你你随便你加，但是你永远如果你采用的这种算法不对，你采用的是整存整取这种分区的算法，不管你加多少内存条都是不够的。
	因为我跟你讲过了，你的系统里面你同时运行的是上百个进程，上百个进程对不对？简单来说，我跟你说拿一个大型的3D游戏，比如说黑神话、悟空，或者说再来一个别的一些大型的3D的东西。它本身它安装包安装出来就一百多个G了，对不对？你说如果说我是整存整取，它运行它需要一百多个G我直接装到内存里面给它换一百多个G那你还有空间去去运行别的吗？没有了是不是？所以整存整取的方式它会导致你的内存空间是不够的。所以这种方式它是早期的那种批处理，我们现在已经不用了。
	我们现在计算机系统普遍采用的就是断页式存储，就是分段和分页。分段和分页简单来说就是什么呢？它的原理就是部分存取，部分存储。好吧，就是说我没有必要说你一个程序运行需要多少内存，我就把内存一开始全部都给你。没有必要，因为你一个进程并不什么，你并不是你所有的一个程序，并不是你所有的东西都要同时运行的。
	你可能什么是加载一部分东西，再加载另外一部分东西。就比如说大家玩游戏一样的，对不对？你进入一个副本，我们就加载这个副本的内容，你别的副本你不进入，我们不会去加载它。我们不会说把整个游戏全部都加载到内存里面，是不是？所以我们采用这种部分存取的方式，我们每一个进程只加载它当前运行的这一部分，那么就可以容纳我们上百个进程同时在内存里面运行。而且我们内存空间还很大，所以现在其实大家内存的话，有个32GB，64GB就非常的宽裕了是吧？非常宽裕了，就是因为这种算法机制OK。
	那我们再看一下分页具体怎么进行部分存储的？很简单它会把我们的程序给进行分页。这个程序的分页的话，它称之为叫逻辑页。他会把我们的内存空间也给它分页，这个页的话它称为叫物理块，或者说叫页框物理块，或者说叫叶况。很明显大家就知道叶况是干嘛的，框是用来装页的，页框是用来装页的，对不对？也就是说我们这里分分的这个页的大小和页框的大小是固定的，而且是一样的大小。比如说我们可以把它都分为4KB就一页和一页框的大小都是4KB页的大小是固定的这是最重要的一个特点，固定的好吧？
	那么这个时候，当我们的程序想要装载到内存里面进行运行的时候，我们就会遇到一个问题。什么问题？就是我们如何把我们程序里面的逻辑页的地址给它装到我们内存里面的物理的页框里面。也就是说这个时候我们就会遇到一个叫逻辑地址到物理地址的一个转换的问题，对吧？转换的问题这个转换的问题是我们的一个考点，就是逻辑地址到物理地址的一个计算，好吧，一个计算。
	那么这个计算怎么算呢？我们首先了解一下我们这个叶地址的一个组成。我们的叶地址有两个字段组成。第一位的称为叫页内地址，或说页内偏移，高位的称之为叫液耗。那么这个页内偏移和液耗是什么意思呢？它其实就是标明你当前在这里的第几页的第几个字节。
	比如说简单来说，假设页号是8页内地址是100。它其实告诉你，你当前在什么呢？你当年在这个程序的第八页里面的第100个字节，懂吗？因为我们看我们刚才一页分类一共是4KB，4KB有4096个字节，对不对？它就是这么标识。
	这样的话，也还有一个有意思的地方，就是在于什么呢？就在于你可以看到这里它的这个这里我给大家一个提示，就比如说我们这个页内地址，除了标识它是第几个字节，还可以表示整个页的大小。比如说假设我们的页内地址是MV它其实表示我们整个页的大小。
	就是二的N次方。
	个字节。为什么为什么？因为二进制为N位，一共可以表示二的N次方个数。举个特例，比如说两位，两位是不是可以表示四个数？00011011，三位就是000001010，你自己去数对不对？所以如果说我们页内地址为N位，其实它代表的就是我们的页大小是二的N次方。
	比如说刚才我们讲的，假设题目给了我们的业内页大小是4KB那么我们就可以得出它的业内地址是什么，是12位。因为二的12次方是4K，对吧？是12位，那么这个东西有什么意义呢？我们来看一下逻辑地址到物理地址转换的一个细节。你可以看到大家看一下这个图，这里我们的页号和页内地址分别是4和256。就表明我们当前在这个程序里面是第四页第256个字节，这是逻辑地址。我们要把它转换为物理地址，怎么转换呢？首先你看到它的页内地址，直接拿下来不变。
	发现没？业内。
	地址是不变的，为什么？很好理解，因为我跟你讲过了，叶大小和页框的大小是一样的，就是大家都是4KB，那我相对顺序就没有必要变了。你在我这个页里面是第256个字节，那你在我这个内存的这个页框里面，你也是第256个字节。因为大家大小是一模一样的，相对顺序就是一样的。所以业内地址不用变，但是页号肯定不一样，对吧？因为你所有的程序都要装载到内存里面，你页耗不可能跟逻辑页号是一样的。
	那么这个页号怎么办呢？你看到我们把页号独立出来，然后页号会去查一个叫页表的东西。这个页表考试的时候题目会给你，不用管它从哪来的，好吧？你看这个页表记录了什么呢？这个页表记录了我们的逻辑页号和物理块号，就是页框的一个对应关系。那么我们就直接去查我们的页号是4，我们找到它对应的物理块号是15，那我们就把这个跟我们的业内地址给拼在一起就可以了。你看到没？15、256，这是我们的物理地址，这就标志着它在我们的内存里面是存在什么。
	第15个页框里面的第256个字节。所以你看到这里，我们完成逻辑地址到物理地址转换，我们该如何去做？整个看完我们该如何去做。第一步我们要先分离出页号和什么业内地址，就是他会给你一个整体的一个地址。
	比如说可能是1A2B这样的一个16进制，给你一个整体的地址，他不会单独告诉你就是说哪个是一号，哪个是业内地址，好吧？那么给你一个整体的地址之后，你要首先从这里面分离出哪个是一号，哪个是业内偏移。然后第二你分离出来了之后，你的怎么样，你就按照这个步骤页内偏移不变页号去查题目里面的页表。然后把这个物理查出来的这个物理块号跟业内偏移拼到一起，就变成了我们的物理地址，是不是？所以这里面有一个难点就在于我们如何去分离出一个地址里面的页号和页内偏移。
	如何去分离出如何分离呢？就是根据我刚才跟你讲的，就是我们首先要根据这个叶大小去求出我们页内偏移的位数。他告诉你叶大小是4KB你转化为二的幂指数，你就知道业内偏移是12位。也就是说你把这个地址转换为二进制，它的第12位就是业内地址，剩余的高位就是页号。你就根据这个把业内偏移和页号给分开了，知道吗？这是他的求法。等一下我们去看题目你就知道。现在你先了解一下OK，然后接下来我们再来看一下这里的页面置换的算法。页面置换算法就跟那个进程调度那些东西都有点像，好吧？
	就是说当我们我们当前内存里面分配给你的这个页框满了之后，那这个时候你就要把什么你就要把你当前内存里面的页给它调出去，把你将要执行的页给它调进来知道吧？这个叫页面置换。页面置换的话，我们要注意，我们遵循的是局部性原理。就是说我们总是要把什么，把将来要执行的，或者说最有可能执行的数据给它调进来。
	那么这个时候你觉得我们应该怎么去采用什么算法呢？它这里有你看到有一种叫最优算法，这个算法是一种理论上的算法，这是没有办法实现的好吧？它是指什么呢？就是我们进程执行完之后，我们的一个最佳效率的计算。因为它是一个可以预测未来的算法。预测未来的算法就是说它先运行一遍程序，看这个程序它的他他要访问的哪那些页是哪些页。然后第二遍预警的时候，我们就按照这些页的顺序来调，所以它是一个预测未来的，好吧？
	预测未来的，我说要执行两遍的，先进先出，这个是最常见的。就是你先进入内存的，我先把你淘汰掉，就是先淘汰掉对不对？这最常见的。但这种算法的话没有任何规律可言，它会产生抖动现象，就说你给他的分配的内存越多，反而可能会效率越低。
	然后最近最少使用算法，这是我们现在的我们现在计算机普遍采用的夜视存储的调度。好吧，最近最少使用它是符合我们讲的局部性原理的。他会怎么样？把过去最少使用的页面被置换淘汰，就在最近的过去最少使用的。因为我们局部性原理是什么样的？局部原理是指的是如果说这个数据我最近使用了，那么未来我有很有可能会再次使用，对吧？那反过来的意思就是什么呢？就是最近我没有使用，那未来我也不会使用，所以我把它淘汰掉好吧？
	好，然后呢这里我们要注意一个淘汰的原则，就是我刚才跟大家讲默认的情况下，就是说如果说题目里面问你这种淘汰哪一个，如果说他没有给你具体的算法，他如果给了你算法，你按照给的算法的原理去淘汰。如果他没有给你算法，默认一般采用的都是LRU，因为这是我们现在系统默认使用的那你注意你要优先淘汰掉没有被访问过的。如果说都被访问过，你要去优先淘汰没有被修改过的。有时候他考试里面会给你这两个状态，好吧？访问是第一优先级，修改是第二优先。如果访问就已经决定了，那么就不用看修改了。懂了吧？
	好，然后接下来还有一个快表的概念，快表是什么？快表是一块叫小容量相联存储器，就是块表和页表的关系，就相当于cash和储存的关系，能理解吧？Cache是怎么存的？是储存的数据的副本，而且是主存里面什么最活跃的那部分数据。那块表也是这样的。快表本身存的内容是页表的副本，而且存的什么呢？是列表里面最活跃访问最多的那部分数据的副本，好吧？同样快表也是存在我们的case里面的。这样当我们的CPU要去访问页表的时候，首先他会去访问cache里面的块表，看能不能把这个数据给他直接访问掉，转换掉，转换掉就不用再去访问内存里面的列表，好吧，这样可以提升效率。
	然后接下来我们。
	再来看分段段式存储分段的话我们可以看到我们把我们的进程空间分成一个个段，每个段的话它也有段昊和段内地址。那么分段也是部分存取，它跟分页有什么区别呢？就是它的物理大小是不固定的，这个区别要注意。分页它的什么？它的每一页和叶框的大小都是固定的。而分段的话，每一段的大小都是不固定的。
	不固定它是怎么分的呢？它是根据逻辑内容来分段的，所以它的物理大小就不固定。逻辑内容什么意思？就比如说我们当前有一个业务流程一个功能，它一个完整的功能当成一段。比如说他一个排序算法，一个什么样的算法，这些算法当成一段，它根据这个逻辑功能来分类，那这样的话，它物理上就不是固定的，好吧，所以就有利有弊。因为它逻辑上是一个整体，那么你把这一段调进去，相当于你所要访问的这个内容都在这一段里面了。因为它逻辑上是一个整体，对不对？那么物理上不固定就是不好管理，对吧？
	不好管理。那我们可以看一下下面段的话，段的地址一般来说几乎不会考，但是它跟页的地址是一样的。你可以看一下，它也是包括两个字，段是高位是段昊，低位是段内偏移。你看那页也是页号和页内偏移，对吧？它的地址转换也是一样的，段内地址也是不变，因为什么呢？
	虽然每一段的大小不一样，但是我们逻辑段和物理段的大小是一样的。就是说你调到物理内存里面，还是给你分配一个跟这一段的大小一样的，好吧，所以断裂电子也不用变。然后段号的话也是一样，要去查一个段表，查一个段表好吧。但这个断表的话，它跟页表就不一样，因为断表的话它会显示你的断长和基地址，你要保证这里面不越界好吧？就是你要查找的这个东西不要超过它的断肠，它有一个这样一个特点。
	好，然后的话。
	我们再来看一下这个叫断页式存储。段页式很简单，就是按照顾名思义就是先分段后分页，所以叫断叶式。它就是按照这个名字顺序来的，先分段后分页好吧？那么它的特点就是什么呢？就是你看到它这里的话，它断页式的话，它就会既有段昊又有段里面的液号，还有页内偏移。
	你说他对于我们的这个程序，因为我们现在的这个程序还有文件都很大，你单纯用段式或者说夜市的话不好表示，所以就一起断页式，它会对我们一个很大的一个程序，它会什么呢？先分段，这个分段是按照逻辑分的。比如说这个逻辑功能是一段，这个逻辑功能是一段，然后在这个段里面再分页，这个页就是固定大小的，就是固定大小的，对不对？所以它最低的地址是业内地址，因为它最低里面是分页的。然后的话就是段里面的页号，这段里面的第几个页，然后是最外围的段号。因为它最外围是分段的段号，所以它的地址有三个字段很好理解你也是按照断言式，先断后页，然后在页内按照顺序来记就可以了。断言式不要记混了好吧，都在他的名字里面。他的这个地址的话是不会考的，从来没有考过，但你可以大概了解一下，好吧？
	好，然后接下来的话我们可以来看一下存储管理这一块的这个真题。存储管理的提议就不多了就不多了，就是一个地址的一个问题好吧？首先是我们刚才看到这个夜市地址的一个转换。刚才跟你讲了分页的转换该怎么转，对不对？页号页内偏移该怎么求，是不是你可以看一看，你看某计算机系统页面大小为4K若进程的页面转换门就是列表，逻辑地址是16进制的ED16，该地址经过变换后，它的物理地址应该是16进制的多少？
	我们说了，你要求这个第一步就是搞清楚这个地址它的页号是多少，它的页内偏移是多少。怎么搞清楚这个东西通过什么？通过它的页大小？叶大小是4K把它转换成二的幂指数是二的12次方，那么这个十二就是我们业内偏移的位数。也就是说我们知道这个地址它的第12位是业内偏移高位，就是页号。那么你只需要把它转化为二进制，然后看第12位是多少，对吧？
	但是这里我们有一个取巧的就是什么呢？就是我们知道一位16进制可以转化，为什么四位二进制？所以你第12位在16进制里面就什么？就是第三位34 12。所以我们就知道这里的第三位第一六就是业内地址。
	那么它。
	高位的这个一就什么？就是页号。接下来我们就第二步，就是页内地址是不变的，还是第16页号去查页表一对应这个物理块号是三，那么拼在一起就什么3D16对吧？3D16这个要注意。
	好，就是一个段地址的问题。段地址的话一般他不会去考段地址的转换，从来没考过。一般可能就是像这样的一个题目，就是断那个越界的问题。
	可以看一下是某进程的段表，如下所示。逻辑地址什么可以转换为对应的物理地址？那哪一个逻辑地址可以转换为物理地址？这里问的比较奇怪，对不对？什么叫可以转换？他其实就是问你哪一个地址是合法的，他不是非法的，知道吧？
	那这里你看一下，我们这段地址也是什么？跟页地址一样，也是段昊和段内地址，对不对？页地址也是一样，页号页内地址。那这里你就知道这是段昊，这是段内地址，什么意思呢？你看到段号是零就在这里，段内地址是1597，那么这个地址有没有问题？
	这个地址很明显是有问题的，为什么？因为段号为零，它的段长是600，看到没？就说这一段一共只有600个字节，结果你要访问它的第1597个字节，它有第1597个字节吗？没有，这是越界。所以他这个考点是在这里是吧？这个地址是错误的，地址是越界的。你不要把这个东西当成基地址，好吧，断肠是600，他没有1597是这个意思。所以接下来你就一个去对你就看了0 128，128是有的，1 31段长是50，30是有的，三三段长是29881390是有的。那么B这个地址就都可以，所以B的地址都是对的，C和D里面地址有错的，你可以自己去找一下，好吧，这个我就不找了，很简单，很简单，就注意这个断肠和基地址不要搞混就行了。

（内容由AI生成）